[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Optimización de redes",
    "section": "",
    "text": "Presentación"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Ahuja, Ravindra K, Thomas L Magnanti, and James B Orlin. 1995.\nNetwork Flows: Theory, Algorithms and Applications. Prentice\nHall.\n\n\nBazaraa, Mokhtar S., John J. Jarvis, and Hanif D. Sherali. 2011.\nLinear Programming and Network Flows. Wiley-Interscience.\n\n\nChen, Wai-Kai. 1990. “Theory of Nets: Flows in Networks.”\n\n\nChen, Yunran. 2019. “Introduction to Network Analysis Using\nr.” https://yunranchen.github.io/intro-net-r/index.html.\n\n\nDeo, Narsingh. 2017. Graph Theory with Applications to Engineering\nand Computer Science. Courier Dover Publications.\n\n\nEvans, James R, and Edward Minieka. 1992. Optimization Algorithms\nfor Networks and Graphs. CRC Press.\n\n\nRao, Singiresu S. 2009. Engineering Optimization: Theory and\nPractice: Fourth Edition. Engineering Optimization: Theory and\nPractice: Fourth Edition.\n\n\nRay, Santanu Saha. 2013. Graph Theory with Algorithms and Its\nApplications: In Applied Science and Technology. Springer.\n\n\nSierksma, Gerard, and Diptesh Ghosh. 2010. Networks in Action: Text\nand Computer Exercises in Network Optimization. Springer."
  },
  {
    "objectID": "index.html#descripción",
    "href": "index.html#descripción",
    "title": "Optimización de redes",
    "section": "Descripción",
    "text": "Descripción\nEl curso de Optimización de redes presenta las herramientas matemáticas básicas para resolver problemas de ingeniería y ciencias que tienen estructuras y propiedades especiales dentro de los problemas de programación matemática. Durante el desarrollo del curso, se tratarán algunos aspectos teóricos y conceptuales, por lo que es importante que el estudiante tenga bases claras en álgebra lineal y en los cursos de programación lineal y optimización discreta. Así mismo, se procurará un enfoque práctico, usando lenguajes de programación como R y Python, para resolver problemas reales y complejos."
  },
  {
    "objectID": "index.html#objetivos",
    "href": "index.html#objetivos",
    "title": "Optimización de redes",
    "section": "Objetivos",
    "text": "Objetivos\n\nIdentificar problemas de optimización que puedan ser representados a través de redes\nComprender y aplicar los métodos más importantes usados en la optimización de redes\nProgramar algoritmos en lenguajes como R y Python para resolver problemas complejos de redes\nPlanear, ejecutar y comunicar de manera clara, proyectos de ingeniería que involucren métodos de redes para la toma de decisiones"
  },
  {
    "objectID": "index.html#metodología",
    "href": "index.html#metodología",
    "title": "Optimización de redes",
    "section": "Metodología",
    "text": "Metodología\nEl contenido del curso será presentado en sesiones presenciales los días lunes a las 12:00pm y jueves a las 8:00am. Durante las clases se irán desarrollando de manera simultánea conceptos y código en R, por lo que es necesario estar en salas de informática.\nEl estudiante es responsable de trabajar semanalmente en el curso para afianzar los temas dados. se realizarán exámenes cortos1 periódicamente para evaluar la evolución de cada estudiante en la asimilación de los temas. Se dejarán talleres/tareas para estimular la investigación y profundización de los temas vistos durante las clases."
  },
  {
    "objectID": "index.html#evaluación",
    "href": "index.html#evaluación",
    "title": "Optimización de redes",
    "section": "Evaluación",
    "text": "Evaluación\nLa nota final se calculará como el promedio de 4 cortes de igual ponderación (25%). Cada corte tendrá los siguientes componentes:\n\n\n\n\n\n\n\n\n\n\nCortes\nComponentes\n\n\n\n\nPrimer corte (25%)\nEvaluaciones de Seguimiento, quices, talleres, exposiciones, trabajos (12%)\nAsistencia (puntualidad), Participación en clase (2%)\nEvaluación parcial (11%)\n\n\nSegundo corte (25%)\nEvaluaciones de Seguimiento, quices, talleres, exposiciones, trabajos (12%)\nAsistencia (puntualidad), Participación en clase (2%)\nEvaluación parcial (11%)\n\n\nTercer corte (25%)\nEvaluaciones de Seguimiento, quices, talleres, exposiciones, trabajos (12%)\nAsistencia (puntualidad), Participación en clase (2%)\nEvaluación parcial (11%)\n\n\nCuarto corte (25%)\nEvaluaciones de Seguimiento, quices, talleres, exposiciones, trabajos (10%)\nEvaluación o proyecto final (15%)"
  },
  {
    "objectID": "index.html#clases-programadas",
    "href": "index.html#clases-programadas",
    "title": "Optimización de redes",
    "section": "Clases Programadas",
    "text": "Clases Programadas\n\n\n\n\n\nSemana\nFecha\nTemas\n\n\n\n\n1\nenero 16\nMotivación. Modelación matemática. Problemas de optimización\n\n\n2\nenero 23\nClasificación de problemas y técnicas de optimización. Problemas de redes y aplicaciones\n\n\n3\nenero 30\nGrafos. Definiciones y teoría matemática\n\n\n4\nfebrero 06\nVisualización\n\n\n5\nfebrero 13\nEstructuras de datos y representación computacional de redes. Examen 1\n\n\n6\nfebrero 20\nEstructuras de datos y representación computacional de redes\n\n\n7\nfebrero 27\nCaminos y ciclos. Árboles. Complejidad computacional\n\n\n8\nmarzo 06\nÁrbol de mínima expansión. Teoría, algoritmos y aplicaciones\n\n\n9\nmarzo 13\nRuta más corta. Teoría, algoritmos y aplicaciones\n\n\n10\nmarzo 20\nRuta más corta. Teoría, algoritmos y aplicaciones. Examen 2\n\n\n11\nmarzo 27\nFlujo de costo mínimo\n\n\n12\nabril 03\nSemana Santa\n\n\n13\nabril 10\nFlujo máximo\n\n\n14\nabril 17\nAsignación, localización, emparejamiento. Examen 3\n\n\n15\nabril 24\nRuteo de nodos. Ruteo de arcos\n\n\n16\nmayo 01\nAplicaciones adicionales de redes\n\n\n17\nmayo 08\nAplicaciones adicionales de redes"
  },
  {
    "objectID": "index.html#sobre-el-reglamento",
    "href": "index.html#sobre-el-reglamento",
    "title": "Optimización de redes",
    "section": "Sobre el Reglamento",
    "text": "Sobre el Reglamento\n\nEs necesario que el estudiante participe como mínimo en el 80% del desarrollo del curso (clases). La inasistencia será causal de pérdida del curso con una calificación de cero punto cero cero (0.00), sin posibilidad de cancelación del curso, si la inasistencia fue reportada previamente al sistema de información.\nLa inasistencia por razones de enfermedad o fuerza mayor deberá justificarse dentro de los tres (3) días hábiles siguientes al hecho. Cuando el estudiante requiera ausentarse para eventos académicos, científicos, culturales y deportivos, en representación de la Universidad, deberá reportar este hecho al profesor, como mínimo con ocho (8) días hábiles de anticipación.\nEn cualquiera de las clases se pueden hacer actividades evaluativas de seguimiento (quices, talleres cortos, ejercicios en clase), con o sin programación previa.\nLa no presentación de una evaluación en la fecha y hora fijada por el profesor conlleva una nota de 0.00 (cero punto cero cero).\nCuando, por causas justificadas, no se puedan presentar las evaluaciones parciales o finales en las fechas establecidas por el docente, se podrán solicitar pruebas supletorias2 ante el director de la Facultad. Estas pruebas tendrán un costo y deberán ser solicitadas dentro de los tres (3) días hábiles siguientes a la programación de la prueba no presentada por el estudiante y, si es autorizada, deberá ser presentada dentro de los 10 días hábiles siguientes a su autorización.\nLos resultados de las evaluaciones deberán ser informados al estudiante, a más tardar, dentro de las dos (2) semanas siguientes a su presentación.\n\n\n\n\n\nAhuja, Ravindra K, Thomas L Magnanti, y James B Orlin. 1995. Network Flows: Theory, Algorithms and Applications. Prentice Hall.\n\n\nBazaraa, Mokhtar S., John J. Jarvis, y Hanif D. Sherali. 2011. Linear Programming and Network Flows. Wiley-Interscience.\n\n\nChen, Wai-Kai. 1990. «Theory of Nets: Flows in Networks».\n\n\nChen, Yunran. 2019. «Introduction to Network Analysis Using R». https://yunranchen.github.io/intro-net-r/index.html.\n\n\nDeo, Narsingh. 2017. Graph Theory with Applications to Engineering and Computer Science. Courier Dover Publications.\n\n\nEvans, James R, y Edward Minieka. 1992. Optimization Algorithms for Networks and Graphs. CRC Press.\n\n\nRao, Singiresu S. 2009. Engineering Optimization: Theory and Practice: Fourth Edition. Engineering Optimization: Theory and Practice: Fourth Edition.\n\n\nRay, Santanu Saha. 2013. Graph Theory with Algorithms and its Applications: in Applied Science and Technology. Springer.\n\n\nSierksma, Gerard, y Diptesh Ghosh. 2010. Networks in Action: Text and Computer Exercises in Network Optimization. Springer."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Optimización de redes",
    "section": "",
    "text": "No es necesario que estas evaluaciones rápidas o quices sean programadas o avisadas con anticipación, pueden realizarse en cualquier clase y en cualquier momento de la clase. Si \\(p_k\\) es la probabilidad de haya quiz en la k-ésima clase, entonces \\(p_k&gt;0 \\ \\forall k\\)↩︎\n\\(\\$109.796\\) para el año 2022↩︎"
  },
  {
    "objectID": "r-intro.html#instalación",
    "href": "r-intro.html#instalación",
    "title": "1  Introducción al uso de R",
    "section": "1.1 Instalación",
    "text": "1.1 Instalación\nPara trabajar con R, es necesario instalar el lenguaje en sí y un IDE (por sus siglas en inglés, Integrated Development Environment). Un IDE es una herramienta que facilita el trabajo con el lenguaje de programación, hay varias opciones para R, usaremos Rstudio.\nSiga los siguientes pasos para la instalación:\n\nDescargar e instalar R según el sistema operativo que se tenga.\nDescargar e instalar la versión de Rstudio Desktop\n\nSe recomienda instalarlo en el orden dado para que Rstudio reconozca automáticamente la versión de R ya instalada. Cuando esté todo listo, se ejecuta la aplicación de Rstudio, desde donde haremos todo el trabajo.\nEn Rstudio: file -&gt; New File -&gt; R script (atajo: ctrl+shift+N), abrirá un editor en blanco para empezar a codificar. Al hacerlo, debe verse como en la imagen\n\n\n\nFigura 1.1: Rstudio IDE\n\n\nGuarde su trabajo desde el menú: File -&gt; Save As; o con: ctrl+S."
  },
  {
    "objectID": "r-intro.html#lo-básico",
    "href": "r-intro.html#lo-básico",
    "title": "1  Introducción al uso de R",
    "section": "1.2 Lo básico",
    "text": "1.2 Lo básico\n\nR es un lenguaje de tipado dinámico y de alto nivel (o sea, fácil de aprender)\nEl operador de asignación es &lt;-. Atajo de teclado: Alt + -. Asignación es el proceso mediante el cual guardamos los objetos que creamos en espacios de memoria o variables\nEs posible usar también el signo igual (=) como operador de asignación, aunque en algunos pocos casos particulares puede generar confusiones, por lo que es recomendable usar &lt;-\nPara agregar comentarios al código use el signo #. Todo lo que escriba en R, después de un signo #, será ignorado. Sirve para comentar el código\nPuede ejecutar una línea o un subconjunto de líneas seleccionadas del código con ctrl + enter. Sitúe el cursor en cualquier parte de la línea a ejecutar o seleccione las líneas deseadas. Dependiendo de las líneas ejecutadas, puede encontrar un resultado impreso en la consola, una gráfica, unas variables agregadas al entorno, etc.\nLos nombres de las variables deben empezar con una letra1 y luego cualquier carácter alfanumérico. Los únicos caracteres especiales permitidos son el punto (.) y el guión bajo (_), útiles cuando se quiere usar nombres compuestos\nLos nombres de variables no deben contener espacios\n\nEjemplos de asignación de valores a variables:\n\na1 &lt;- 56 # numeric\nb = 12.3 # numeric\nb = b + 1\na &lt;- \"hola\" # character\nx_1 &lt;- 3L # integer\nx2 &lt;- FALSE # logical\nx.3 &lt;- 1 + 3i # complex\nvel_inicial &lt;- 47.31 # Velocidad inicial en km/h\n\nAlgunos consejos:\n\nUsar nombres relacionados con lo que se está codificando para ayudar a entender mejor el código. Por ejemplo, si se está resolviendo un problema en física, donde se necesita almacenar el valor de la velocidad inicial de una partícula, es mejor opción velocidad_incial &lt;- 100, en lugar de var1 &lt;- 100\nNo usar mayúsculas (cuestión de gustos)\nNo usar acentos (tildes)\nComentar comentar comentar, para que cualquiera que lea su código, pueda entenderlo con más facilidad\n\n\nvelocidad &lt;- 80 # velocidad en km/h\nvel_inicial &lt;- 45 # velocidad inicial en km/h"
  },
  {
    "objectID": "r-intro.html#tipos-de-datos-en-r",
    "href": "r-intro.html#tipos-de-datos-en-r",
    "title": "1  Introducción al uso de R",
    "section": "1.3 Tipos de datos en R",
    "text": "1.3 Tipos de datos en R\n\nCharacter\nNumeric\nInteger\nComplex\nLogical\n\n\nx1 &lt;- 'UPB Montería' # las cadenas de texto deben ir entre comillas simples (') o dobles (\")\nclass(x1)  # devuelve la clase del objeto x1\n\n[1] \"character\"\n\npi # pi es una constante pi = 3.1415...\n\n[1] 3.141593\n\nx2 &lt;- pi    \nclass(x2)\n\n[1] \"numeric\"\n\nx3 &lt;- \"AB\" # character\nx4 &lt;- 6L # integer\nclass(x4)\n\n[1] \"integer\"\n\nx5 &lt;- 3.4 + 9.3i # complex\nclass(x5)\n\n[1] \"complex\"\n\nlogico &lt;- FALSE # logical\nclass(logico)\n\n[1] \"logical\""
  },
  {
    "objectID": "r-intro.html#vectores",
    "href": "r-intro.html#vectores",
    "title": "1  Introducción al uso de R",
    "section": "1.4 Vectores",
    "text": "1.4 Vectores\nUn vector es un arreglo unidimensional que puede almacenar datos de un mismo tipo. Podemos tener un vector numérico, por ejemplo, lo que quiere decir que tenemos un arreglo que almacena solo datos de tipo numérico. No se pueden almacenar datos de diferente tipo en un vector, es decir, no puede tener en R un vector con valores numéricos y lógicos mezclados.\nPara crear un vector, se usa la función c() (es una “c” minúscula, R distingue entre mayúsculas y minúsculas). Ejemplos:\n\nvector1 &lt;- c(1,5,7,4) # Vector de solo valores numéricos\nvlog &lt;- c(T, F, F, F, T) # vector de solo valores lógicos\nvchar &lt;- c(\"c\", \"i\", \"e\", \"n\", \"c\", \"i\", \"a\") # vector de caracteres\nvector1; vlog; vchar # imprime los vectores creados\n\n[1] 1 5 7 4\n\n\n[1]  TRUE FALSE FALSE FALSE  TRUE\n\n\n[1] \"c\" \"i\" \"e\" \"n\" \"c\" \"i\" \"a\"\n\n\nSi intentamos almacenar elementos de diferente tipo en un vector, R intentará hacer una coerción a un tipo de dato adecuado.\n\nc(1,2,3,\"hola\") # creará un vector de caracteres\n\n[1] \"1\"    \"2\"    \"3\"    \"hola\"\n\nc(1,2,3,FALSE,TRUE) # creará un vector numérico. T equivale a 1 y F a 0\n\n[1] 1 2 3 0 1\n\n\nHay muchas formas adicionales a la función c() para obtener o crear vectores en R. Algunas formas comunes son:\n\n# una suceción de números enteros desde el 10 hasta el 20 \n# almacenando el resultado en un vector llamado suc1\nsuc1 &lt;- 10:20 \n\n# con la función vector()\nvec1 &lt;- vector(mode = \"numeric\", length = 15)\nvec2 &lt;- vector(\"logical\", 6)\nvec3 &lt;- vector(length=6, mode=\"logical\")\nsuc1; vec1; vec2; vec3\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\n [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nLas funciones como vector pueden usarse sin declarar de forma explícita los argumentos, solo asegúrese de poner los valores en el orden correcto.\nMás ejemplos:\n\n23:15\n\n[1] 23 22 21 20 19 18 17 16 15\n\n# con la función seq() para crear vectores a partir de secuencias\nseq(from = 5, to = 10) # secuencia que empieza en 5 y va hasta el 10 de uno en uno\n\n[1]  5  6  7  8  9 10\n\n# una suceción que empieza en 5 y aumenta en pasos de 0.2 hasta llegar a 10\nseq(from = 5, to = 10, by = 0.2)\n\n [1]  5.0  5.2  5.4  5.6  5.8  6.0  6.2  6.4  6.6  6.8  7.0  7.2  7.4  7.6  7.8\n[16]  8.0  8.2  8.4  8.6  8.8  9.0  9.2  9.4  9.6  9.8 10.0\n\n# desde el 5 hasta el 10, en pasos iguales que permitan un total de 12 números\nseq(from = 5, to = 10, length.out = 12)\n\n [1]  5.000000  5.454545  5.909091  6.363636  6.818182  7.272727  7.727273\n [8]  8.181818  8.636364  9.090909  9.545455 10.000000\n\n# con la función rep() para repetir un objeto, n cantidad de veces\nrep(1.45, 6) # repite el número 1.45 6 veces y genera un vector\n\n[1] 1.45 1.45 1.45 1.45 1.45 1.45\n\nrep(c(1,3), 7) # repite el vector c(1,3) 7 veces\n\n [1] 1 3 1 3 1 3 1 3 1 3 1 3 1 3\n\n\nMuchas funciones y procedimientos en R, devuelven sus resultados en vectores. Por ejemplo, es posible generar números aleatorios de forma muy sencilla y guardarlos en un vector\n\nx &lt;- runif(n=100) # runif() genera números uniformemente distribuidos (entre 0 y 1 por defecto)\n\n# 20 números uniformes entre -3.7 y -1\ny &lt;- runif(n=100, min=-3.7, max=-1) # por supuesto: min &lt; max\n\n# números con distribución normal\nz &lt;- rnorm(n = 100, mean = 2.1, sd = 0.4)\n\nplot(x, y) # gráfico de dispersión\n\n\n\nhist(z) # histograma\n\n\n\n\nPara acceder a los elementos de un vector se usan los corchetes []\n\nx &lt;- rnorm(n=20, mean = 0, sd = 2) # vector con 20 números\nx # imprime el vector\n\n [1]  2.01373883  3.60047999  1.14562567  0.74842488 -1.14948762 -1.99906082\n [7]  4.18465714  0.65333246 -0.33216170  0.31409230 -0.64894139 -2.93373092\n[13] -0.07799815  0.98050227  1.75978775  1.60189309 -0.14003622 -1.49803540\n[19]  0.14696190 -0.49568110\n\nx[17] # elemento 17\n\n[1] -0.1400362\n\nx[3:10]  # elementos del 3 al 10 inclusive \n\n[1]  1.1456257  0.7484249 -1.1494876 -1.9990608  4.1846571  0.6533325 -0.3321617\n[8]  0.3140923\n\nx[-5]  # todos los elementos menos el quinto\n\n [1]  2.01373883  3.60047999  1.14562567  0.74842488 -1.99906082  4.18465714\n [7]  0.65333246 -0.33216170  0.31409230 -0.64894139 -2.93373092 -0.07799815\n[13]  0.98050227  1.75978775  1.60189309 -0.14003622 -1.49803540  0.14696190\n[19] -0.49568110\n\nx[c(1,6,4)]  # elementos 1, 6 y 4\n\n[1]  2.0137388 -1.9990608  0.7484249\n\nx[-c(1,6,4)]  # todos los elementos excepto el 1, 6 y 4\n\n [1]  3.60047999  1.14562567 -1.14948762  4.18465714  0.65333246 -0.33216170\n [7]  0.31409230 -0.64894139 -2.93373092 -0.07799815  0.98050227  1.75978775\n[13]  1.60189309 -0.14003622 -1.49803540  0.14696190 -0.49568110"
  },
  {
    "objectID": "r-intro.html#matrices",
    "href": "r-intro.html#matrices",
    "title": "1  Introducción al uso de R",
    "section": "1.5 Matrices",
    "text": "1.5 Matrices\nUna matriz es un arreglo bidimensional para almacenar datos de un mismo tipo (igual que un vector, pero ahora en filas y columnas). Hay varias formas de crear matrices. Se puede usar la función matrix()\n\n# matriz de 3 filas y columnas, si no se asignan valores\n# se llenará cada posición con NA\nmm &lt;- matrix(nrow = 3, ncol = 4)\n\n## Matriz de 3 filas y 4 columnas, cuyos valores están en un vector\n## de números aleatorios uniformemente distribuidos\nmm1 &lt;- matrix(data=runif(12,0,1), nrow = 3, ncol = 4)\nmm1\n\n           [,1]      [,2]      [,3]      [,4]\n[1,] 0.73829765 0.6859696 0.7358050 0.6978778\n[2,] 0.05622985 0.3203104 0.6529075 0.5466102\n[3,] 0.38338761 0.4668784 0.8023674 0.2632238\n\n# Por defecto se llenará la matriz por columnas\nmm2 &lt;- matrix(data = c(1,2,3,4,5,6,7,8,9), nrow = 3)\nmm2\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# note que no especificamos el número de columnas, pero R es \"inteligente\"\n# y sabe que necesita 4 columnas para crear una matriz de 3 filas con 12 elementos\n\n# Si desea \"armar\" la matriz por filas, agregue byrow = TRUE\nmm3 &lt;- matrix(data = c(1,2,3,4,5,6,7,8,9), nrow = 3, byrow = TRUE)\nmm3\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n# Para acceder a los elementos, indique el número de la fila y/o columna\nmm3[3,2]  #elemento (3,2): fila 3, columna 2\n\n[1] 8\n\nmm3[2,]  # toda la fila 2 (un vector)\n\n[1] 4 5 6\n\nmm3[,3]  # toda la columna 3 (un vector)\n\n[1] 3 6 9\n\n\nSe pueden combinar vectores por filas o por columnas para formar matrices\n\nsuc1 &lt;- 1:9\nsuc2 &lt;- 2:10\nmm4 &lt;- cbind(suc1, suc2) # se combina por columnas\nmm5 &lt;- rbind(suc1, suc2) # se combina por filas\nmm4; mm5 # Imprime las matrices en la consola\n\n      suc1 suc2\n [1,]    1    2\n [2,]    2    3\n [3,]    3    4\n [4,]    4    5\n [5,]    5    6\n [6,]    6    7\n [7,]    7    8\n [8,]    8    9\n [9,]    9   10\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\nsuc1    1    2    3    4    5    6    7    8    9\nsuc2    2    3    4    5    6    7    8    9   10"
  },
  {
    "objectID": "r-intro.html#listas",
    "href": "r-intro.html#listas",
    "title": "1  Introducción al uso de R",
    "section": "1.6 Listas",
    "text": "1.6 Listas\nLos vectores y matrices están formados por un único tipo de datos, las listas no tienen esta limitación y se pueden crear con la función list(). Los elementos de una lista pueden ser: numéricos, enteros, lógicos, texto; pueden contener otras estructuras como vectores, matrices, y otras listas.\n\n# una lista que contiene un número entero, un caracter, un número real\n# un vector, una matriz, y otra lista. \nlista1 &lt;- list(3L, \"DF\", pi, c(1.34,2,3), mm1, list(2,\"ss\"))\nlista1\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] \"DF\"\n\n[[3]]\n[1] 3.141593\n\n[[4]]\n[1] 1.34 2.00 3.00\n\n[[5]]\n           [,1]      [,2]      [,3]      [,4]\n[1,] 0.73829765 0.6859696 0.7358050 0.6978778\n[2,] 0.05622985 0.3203104 0.6529075 0.5466102\n[3,] 0.38338761 0.4668784 0.8023674 0.2632238\n\n[[6]]\n[[6]][[1]]\n[1] 2\n\n[[6]][[2]]\n[1] \"ss\"\n\n\nPara acceder a sus elementos se usan dobles corchetes [[]]\n\nlista1[[2]] # segundo elemento de la lista\n\n[1] \"DF\"\n\n# Primer elemento del vector que está el el lugar 4 de la lista (¡reloco!)\nlista1[[4]][1]  \n\n[1] 1.34\n\n\nR es un lenguaje muy versátil y trae por defecto muchas opciones de cálculo. Además de eso, es posible ampliar la gama de operaciones o actividades que se pueden realizar con la instalación de paquetes o librerías adicionales. Es un lenguaje bastante popular y con una comunidad muy activa. Si tiene algún problema con algún código, muy seguramente otra persona ya tuvo el mismo problema antes y se puede encontrar la solución en línea. Cuando tenga un resultado inesperado puede, copiar y pegar el error en Google para buscar soluciones."
  },
  {
    "objectID": "r-intro.html#valores-faltantes",
    "href": "r-intro.html#valores-faltantes",
    "title": "1  Introducción al uso de R",
    "section": "1.7 Valores faltantes",
    "text": "1.7 Valores faltantes\nUn vector de valores lógicos puede usarse para extraer elementos de otro vector. Se extraerá cada elemento en el que haya un valor TRUE\n\nxx &lt;- 20:26 # vector con 7 elementos\nind &lt;- c(T, T, F, F, T, T, T)\nxx[ind]  # extrae las posiciones donde hay TRUE: 1,2,5,6,7\n\n[1] 20 21 24 25 26\n\n\nTipos de datos especiales:\n\nNA: Not Available\nNaN: Not a Number\n\n\n2/0\n\n[1] Inf\n\n0/0\n\n[1] NaN\n\n\nCon alguna combinación de funciones podemos sacar datos NA y/o NaN de un vector\n\nzz &lt;- c(1,2,NA,Inf,NA, NaN, NA, 4, NA)\n\n# devuelve un vector con elementos TRUE donde hay valores NA o NaN\nss &lt;- is.na(zz) \n\n# Vector con elementos TRUE donde hay valores NaN\nss1 &lt;- is.nan(zz) \n\n# con el operador ! cambiamos TRUE por FALSE y viceversa\nssneg &lt;- !ss # en ssneg hay TRUE donde no hay valores NA o NaN\n\n# extrae valores donde ssneg es TRUE, es decir donde no hay valores\n# NA o NaN en zz (¡qué enredo tan bueno!)\nzzlimpio &lt;- zz[ssneg] \nzz; zzlimpio # imprimir y comparar\n\n[1]   1   2  NA Inf  NA NaN  NA   4  NA\n\n\n[1]   1   2 Inf   4"
  },
  {
    "objectID": "r-intro.html#paquetes-o-librerías",
    "href": "r-intro.html#paquetes-o-librerías",
    "title": "1  Introducción al uso de R",
    "section": "1.8 Paquetes o librerías",
    "text": "1.8 Paquetes o librerías\nHay paquetes para hacer casi cualquier cosa en R. Aquí puede econttrar una lista de los paquetes disponibles para instalación directa desde la consola de R (hay más de 20.000).\nPara instalar y luego cargar paquetes:\n\ninstall.packages(\"nombre_paquete\"): solo se hace una vez, por lo que no es necesario incluirlo en el editor (la parte donde se escribe el código) sino que se puede realizar una única vez en la consola (la parte inferior izquierda de Rstudio donde se imprimen los resultados)\nlibrary(nombre_paquete): debe hacerse siempre que se inicie una nueva sesión y se vaya a usar el paquete, normalmente se cargan las librerías a usar al comienzo del código"
  },
  {
    "objectID": "r-intro.html#más-vectores",
    "href": "r-intro.html#más-vectores",
    "title": "1  Introducción al uso de R",
    "section": "1.9 Más vectores",
    "text": "1.9 Más vectores\n\nx1 &lt;- rep(0,20)\nx2 &lt;- seq(from=0, to=2, length.out=5)\nx3 &lt;- seq(from=0, to=2, by=0.2)\nx4 &lt;- 3:12\n\n# La función sample() es bastante útil\n# Extrae una muestra tamaño 3, del vector x4\nx5 &lt;- sample(x4, size = 3, replace = F) # sin reemplazo\nx6 &lt;- sample(x4, size = 15, replace = T) # con reemplazo\nx1; x2; x3; x4; x5; x6\n\n [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n\n[1] 0.0 0.5 1.0 1.5 2.0\n\n\n [1] 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0\n\n\n [1]  3  4  5  6  7  8  9 10 11 12\n\n\n[1] 11 12  8\n\n\n [1]  5 11 10  7  6  4 11  7  3  6 12  8  9 10  8\n\n\nCuando se trabaja con números aleatorios es posible establecer una semilla, para poder reproducir los mismos resultados en diferentes computadores\n\n# se establece la semilla, esto permite que los números \n# generados sean iguales en otros computadores, \n# siempre que tengan la misma semilla establecida\nset.seed(234) \nx7 &lt;- rnorm(1000, mean = 0, sd=1)\nhist(x7)\n\n\n\nx8 &lt;- c(\"c\", \"i\", \"e\", \"n\", \"c\", \"i\", \"a\")\nx9 &lt;- sample(x8, size = 15, replace = T)\nx9\n\n [1] \"c\" \"i\" \"e\" \"i\" \"c\" \"c\" \"e\" \"e\" \"c\" \"n\" \"i\" \"i\" \"e\" \"i\" \"c\""
  },
  {
    "objectID": "r-intro.html#algunas-funciones-básicas-para-usar-con-vectores",
    "href": "r-intro.html#algunas-funciones-básicas-para-usar-con-vectores",
    "title": "1  Introducción al uso de R",
    "section": "1.10 Algunas funciones básicas para usar con vectores",
    "text": "1.10 Algunas funciones básicas para usar con vectores\n\nmin_x7 &lt;- min(x7) # devuelve el valor mínimo en el vector\nmax_x7 &lt;- max(x7) # devuelve el valor máximo en el vector\n\n# devuelve la posición del vector donde se encuentra el valor mínimo\ndonde_min &lt;- which.min(x7) \n# devuelve la posición del vector donde se encuentra el valor máximo\ndonde_max &lt;- which.max(x7)\n\nmin_x7; donde_min\n\n[1] -3.03609\n\n\n[1] 8\n\nmax_x7; donde_max\n\n[1] 3.096502\n\n\n[1] 528\n\n\nPara borrar objetos de la memoria:\n\nrm(ind, logico, max_x7) # borra los objetos ind y max_x7\nrm(list = ls()) # borra todo"
  },
  {
    "objectID": "r-intro.html#funciones",
    "href": "r-intro.html#funciones",
    "title": "1  Introducción al uso de R",
    "section": "1.11 Funciones",
    "text": "1.11 Funciones\nR está optimizado para trabajar con funciones. Una función es un conjunto de líneas de código que se guardan en memoria y que se puede llamar siempre que sea necesario en otras partes del código, sin necesidad de volver a escribir todo lo que hace dicha función\nLa sintaxis básica para crear una función en R es\nnombre_funcion &lt;- function(&lt;argumentos&gt;){\n  Hacer algo con los argumentos\n  devuelva algún resultado\n}\nPor ejemplo\n\nfuncion_1 &lt;- function(x) x^4 + 6*x + 3\nfuncion_1(3)\n\n[1] 102\n\nplot(funcion_1, 0, 10) #grafica la función en el intervalo especificado\n\n\n\n\nSi las operaciones que hace la función se declaran en una sola línea, no es necesario usar las llaves {}. Si las declaraciones dentro de la función ocupan varias líneas, entonces sí es necesario usar las llaves2\nFunciones de 2 variables\n\nfuncion_2 &lt;- function(x,y){\n  return(x*y + 2*x + log(abs(x+y+1)))\n}\nfuncion_2(2,3)\n\n[1] 11.79176\n\n\nEl concepto de función en R no está limitado a funciones matemáticas tal como estamos acostumbrados, los argumentos de las funciones pueden ser: números, vectores, matrices, listas, otras funciones\n\n## f  una función\n## x es un vector\n## y es una matriz\n\nfuncion_3 &lt;- function(f,x,y){\n  return(f(x) + x*y[,1]) # el resultado debe ser un vector (¿por qué?)\n}\n\nxxxx &lt;- 1:5\nyyyy &lt;- matrix(data = 1:30, nrow = 5, byrow = TRUE)\nfuncion_3(f = funcion_1, x = xxxx, y = yyyy)\n\n[1]  11  45 141 359 783"
  },
  {
    "objectID": "r-intro.html#ejemplo-de-la-instalación-y-uso-de-un-paquete",
    "href": "r-intro.html#ejemplo-de-la-instalación-y-uso-de-un-paquete",
    "title": "1  Introducción al uso de R",
    "section": "1.12 Ejemplo de la instalación y uso de un paquete",
    "text": "1.12 Ejemplo de la instalación y uso de un paquete\nEn R hay muchos paquetes que nos ayudan a hacer gráficas en 3D. Instalemos y usemos el paquete rgl. Note que cada paquete trae nuevas funciones que debemos aprender si es que queremos usarlo, lo bueno es que podemos encontrar documentación en muchos sitios de internet. Aquí encontramos un buen tutorial para usar rgl\nGráfica 3D dinámica con el paquete ‘rgl’\n\nlibrary(rgl) # ya debe estar instalado: install.package(\"rgl\")\nx &lt;- seq(-5.12, 5.12, length.out=200)\ny &lt;- x\n\n# Función rastrigin muy usada en optimización\nrast &lt;- function(x,y){\n  20 + x^2 -10*cos(2*pi*x) + y^2 - 10*cos(2*pi*y)\n}\nrast(0,0) # evalúa la función en el punto (0,0)\n\n[1] 0\n\nz &lt;- outer(x,y,FUN=rast)\nrgl::persp3d(x,y,z, col=\"orange2\", main=\"Rastrigin\")"
  },
  {
    "objectID": "r-intro.html#importar-datos",
    "href": "r-intro.html#importar-datos",
    "title": "1  Introducción al uso de R",
    "section": "1.13 Importar datos",
    "text": "1.13 Importar datos\nPara obtener y cambiar el directorio de trabajo\ngetwd()\nsetwd(\"colocar la ruta de windows, cambiar \\ por /\")\n\n# El archivo Auto.txt debe estar en el directorio de trabajo\nautos &lt;- read.table(file = \"Auto.txt\")\nsummary(autos) # hace un resumen de cada variable en la base de datos autos\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n  acceleration        year           origin          name          \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   Length:392        \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   Class :character  \n Median :15.50   Median :76.00   Median :1.000   Mode  :character  \n Mean   :15.54   Mean   :75.98   Mean   :1.577                     \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000                     \n Max.   :24.80   Max.   :82.00   Max.   :3.000                     \n\nmpg_auto &lt;- autos$mpg  #guarda la variable mpg en el objeto mpg_auto\nclass(autos)\n\n[1] \"data.frame\""
  },
  {
    "objectID": "r-intro.html#estructuras-de-control",
    "href": "r-intro.html#estructuras-de-control",
    "title": "1  Introducción al uso de R",
    "section": "1.14 9. Estructuras de control",
    "text": "1.14 9. Estructuras de control\nif, for, while, repeat; break, next, return\n\n1.14.1 Condicionales\n\n## if(&lt;condicion&gt;){\n##  haga algo\n## } else if(&lt;condicion2&gt;){\n##  haga esto otro\n## } else{\n##  haga esto último\n## }\nx &lt;- 10\nif(x&lt;5){\n  \"X es menor que 5\"\n} else if(x==5){\n  \"X es igual a 5\"\n} else{\n  \"X es mayor que 5\"\n}\n\n[1] \"X es mayor que 5\"\n\n\n\n\n1.14.2 Ciclos\n\n## for(i in &lt;conjunto&gt;){\n##  haga algo por cada elemento\n## }\n\nj &lt;- 1\nfor(i in 1:10){\n  if(i&lt;6){\n    j &lt;- 2*j+i\n    print(log(j))\n  } else{\n    j &lt;- 2*j+i\n    print(cos(j))\n  }\n}\n\n[1] 1.098612\n[1] 2.079442\n[1] 2.944439\n[1] 3.73767\n[1] 4.488636\n[1] -0.2151347\n[1] -0.4080545\n[1] -0.640098\n[1] -0.240842\n[1] 0.9960638\n\nvv &lt;- c(\"primer\", \"programa\", \"en R\", \"Con ciclo for\")\nfor (i in vv){\n  print(i)\n}\n\n[1] \"primer\"\n[1] \"programa\"\n[1] \"en R\"\n[1] \"Con ciclo for\"\n\n\nSe pueden anidar\n\nmm &lt;- matrix(data = seq(from=exp(1), to=pi, length.out=16), nrow = 4)\n\nfor(i in 1:dim(mm)[1]){\n  for(j in 1:dim(mm)[2]){\n    cat(\"El elmento (\", i, \",\", j, \") es: \", mm[i,j], \"\\n\", sep = \"\")\n  }\n}\n\nEl elmento (1,1) es: 2.718282\nEl elmento (1,2) es: 2.831165\nEl elmento (1,3) es: 2.944048\nEl elmento (1,4) es: 3.05693\nEl elmento (2,1) es: 2.746503\nEl elmento (2,2) es: 2.859385\nEl elmento (2,3) es: 2.972268\nEl elmento (2,4) es: 3.085151\nEl elmento (3,1) es: 2.774723\nEl elmento (3,2) es: 2.887606\nEl elmento (3,3) es: 3.000489\nEl elmento (3,4) es: 3.113372\nEl elmento (4,1) es: 2.802944\nEl elmento (4,2) es: 2.915827\nEl elmento (4,3) es: 3.02871\nEl elmento (4,4) es: 3.141593\n\n\n\n\n\n\nAhuja, Ravindra K, Thomas L Magnanti, y James B Orlin. 1995. Network Flows: Theory, Algorithms and Applications. Prentice Hall.\n\n\nBazaraa, Mokhtar S., John J. Jarvis, y Hanif D. Sherali. 2011. Linear Programming and Network Flows. Wiley-Interscience.\n\n\nChen, Wai-Kai. 1990. «Theory of Nets: Flows in Networks».\n\n\nChen, Yunran. 2019. «Introduction to Network Analysis Using R». https://yunranchen.github.io/intro-net-r/index.html.\n\n\nDeo, Narsingh. 2017. Graph Theory with Applications to Engineering and Computer Science. Courier Dover Publications.\n\n\nEvans, James R, y Edward Minieka. 1992. Optimization Algorithms for Networks and Graphs. CRC Press.\n\n\nRao, Singiresu S. 2009. Engineering Optimization: Theory and Practice: Fourth Edition. Engineering Optimization: Theory and Practice: Fourth Edition.\n\n\nRay, Santanu Saha. 2013. Graph Theory with Algorithms and its Applications: in Applied Science and Technology. Springer.\n\n\nSierksma, Gerard, y Diptesh Ghosh. 2010. Networks in Action: Text and Computer Exercises in Network Optimization. Springer."
  },
  {
    "objectID": "r-intro.html#footnotes",
    "href": "r-intro.html#footnotes",
    "title": "1  Introducción al uso de R",
    "section": "",
    "text": "También pueden empezar con un . pero esto crea objetos ocultos↩︎\nCasi siempre es necesario, las funciones no suelen ser tan simples para declararse en una sola línea de código↩︎"
  },
  {
    "objectID": "r-visual.html",
    "href": "r-visual.html",
    "title": "2  Construcción y visualización en R",
    "section": "",
    "text": "3 Visualización\nPodemos cargar los datos desde archivos externos. En este caso, tenemos dos archivos de texto que contienen la información de los vértices y aristas de la red que vamos a trabajar como ejemplo. Descargue desde Moodle los archivos: artistas.txt y vertices.txt, y guárdelos en la misma carpeta en donde tiene el script de R\nejecute el siguiente código para cargar los datos en R\naristas &lt;- read.table(file = \"aristas.txt\", header = T)\nvertices &lt;- read.table(file = \"vertices.txt\", header = T)\nObserve la información en las primeras filas de cada una de estas bases de datos\nhead(aristas)\nhead(vertices)\ninicio\nfin\ndistancia\ntipo\n\n\n\n\n1\n4\n5\ntipo5\n\n\n2\n4\n103\ntipo1\n\n\n2\n5\n86\ntipo4\n\n\n4\n5\n13\ntipo1\n\n\n3\n6\n43\ntipo3\n\n\n1\n8\n33\ntipo4\n\n\n\n\n\n\n\n\n\n\nvertice\ndemanda\ngrupo\n\n\n\n\n1\n32\ngrupo1\n\n\n2\n11\ngrupo2\n\n\n3\n19\ngrupo4\n\n\n4\n15\ngrupo4\n\n\n5\n14\ngrupo3\n\n\n6\n20\ngrupo4\nAl crear la red en R se crea un objeto (con el paquete igraph) que guarda toda la información necesaria para hacer gráficas y cálculos. Hay varias funciones que pueden usarse para crear estos, objetos, antes hemos usado la función graph(edges=edges_list) para crear la red a partir de un vector que contiene las aristas como pares de nodos. En este caso, construiremos la red a partir de un data frame con la función graph_from_data_frame(). Esta función requiere un data frame como primer argumento, y las primeras dos columnas deben corresponder a los puntos iniciales y finales de cada arista, respectivamente\nlibrary(igraph)\nred1 &lt;- graph_from_data_frame(d = aristas, vertices = vertices, directed = T)\nred2 &lt;- graph_from_data_frame(d = aristas, vertices = vertices, directed = F)\nPodemos imprimir la información en cada uno de estos objetos\nred1\n\nIGRAPH 0daadc9 DN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), distancia (e/n), tipo\n| (e/c)\n+ edges from 0daadc9 (vertex names):\n [1] 1 -&gt;4  2 -&gt;4  2 -&gt;5  4 -&gt;5  3 -&gt;6  1 -&gt;8  3 -&gt;8  1 -&gt;9  4 -&gt;9  5 -&gt;9 \n[11] 8 -&gt;9  4 -&gt;10 3 -&gt;11 7 -&gt;11 10-&gt;11 5 -&gt;12 7 -&gt;12 8 -&gt;12 9 -&gt;12 1 -&gt;13\n[21] 6 -&gt;13 7 -&gt;13 8 -&gt;13 10-&gt;13 11-&gt;13 3 -&gt;14 4 -&gt;14 7 -&gt;14 7 -&gt;15 9 -&gt;15\n[31] 13-&gt;15 1 -&gt;16 7 -&gt;16 11-&gt;16 13-&gt;16 14-&gt;16 1 -&gt;17 4 -&gt;17 6 -&gt;17 7 -&gt;17\n[41] 8 -&gt;17 10-&gt;17 1 -&gt;18 6 -&gt;18 15-&gt;18 16-&gt;18 2 -&gt;19 5 -&gt;19 6 -&gt;19 8 -&gt;19\n[51] 1 -&gt;20 3 -&gt;20 5 -&gt;20 7 -&gt;20 8 -&gt;20 9 -&gt;20 12-&gt;20 15-&gt;20 17-&gt;20 18-&gt;20\n\nred2\n\nIGRAPH 0dab26e UN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), distancia (e/n), tipo\n| (e/c)\n+ edges from 0dab26e (vertex names):\n [1] 1 --4  2 --4  2 --5  4 --5  3 --6  1 --8  3 --8  1 --9  4 --9  5 --9 \n[11] 8 --9  4 --10 3 --11 7 --11 10--11 5 --12 7 --12 8 --12 9 --12 1 --13\n[21] 6 --13 7 --13 8 --13 10--13 11--13 3 --14 4 --14 7 --14 7 --15 9 --15\n[31] 13--15 1 --16 7 --16 11--16 13--16 14--16 1 --17 4 --17 6 --17 7 --17\n[41] 8 --17 10--17 1 --18 6 --18 15--18 16--18 2 --19 5 --19 6 --19 8 --19\n[51] 1 --20 3 --20 5 --20 7 --20 8 --20 9 --20 12--20 15--20 17--20 18--20\nCon las funciones E() y V() podemos acceder de manera independiente a las aristas y vértices de cada red. Podemos incluso, agregar nuevos atributos. Por ejemplo\nV(red1)$otro_atributo &lt;- runif(n = length(V(red1)))\nred1\n\nIGRAPH 0daadc9 DN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), otro_atributo (v/n),\n| distancia (e/n), tipo (e/c)\n+ edges from 0daadc9 (vertex names):\n [1] 1 -&gt;4  2 -&gt;4  2 -&gt;5  4 -&gt;5  3 -&gt;6  1 -&gt;8  3 -&gt;8  1 -&gt;9  4 -&gt;9  5 -&gt;9 \n[11] 8 -&gt;9  4 -&gt;10 3 -&gt;11 7 -&gt;11 10-&gt;11 5 -&gt;12 7 -&gt;12 8 -&gt;12 9 -&gt;12 1 -&gt;13\n[21] 6 -&gt;13 7 -&gt;13 8 -&gt;13 10-&gt;13 11-&gt;13 3 -&gt;14 4 -&gt;14 7 -&gt;14 7 -&gt;15 9 -&gt;15\n[31] 13-&gt;15 1 -&gt;16 7 -&gt;16 11-&gt;16 13-&gt;16 14-&gt;16 1 -&gt;17 4 -&gt;17 6 -&gt;17 7 -&gt;17\n[41] 8 -&gt;17 10-&gt;17 1 -&gt;18 6 -&gt;18 15-&gt;18 16-&gt;18 2 -&gt;19 5 -&gt;19 6 -&gt;19 8 -&gt;19\n[51] 1 -&gt;20 3 -&gt;20 5 -&gt;20 7 -&gt;20 8 -&gt;20 9 -&gt;20 12-&gt;20 15-&gt;20 17-&gt;20 18-&gt;20\nPodemos, a partir del objeto de red, extraer varias estructuras de datos tales como:\nas_edgelist(red2)\n\n      [,1] [,2]\n [1,] \"1\"  \"4\" \n [2,] \"2\"  \"4\" \n [3,] \"2\"  \"5\" \n [4,] \"4\"  \"5\" \n [5,] \"3\"  \"6\" \n [6,] \"1\"  \"8\" \n [7,] \"3\"  \"8\" \n [8,] \"1\"  \"9\" \n [9,] \"4\"  \"9\" \n[10,] \"5\"  \"9\" \n[11,] \"8\"  \"9\" \n[12,] \"4\"  \"10\"\n[13,] \"3\"  \"11\"\n[14,] \"7\"  \"11\"\n[15,] \"10\" \"11\"\n[16,] \"5\"  \"12\"\n[17,] \"7\"  \"12\"\n[18,] \"8\"  \"12\"\n[19,] \"9\"  \"12\"\n[20,] \"1\"  \"13\"\n[21,] \"6\"  \"13\"\n[22,] \"7\"  \"13\"\n[23,] \"8\"  \"13\"\n[24,] \"10\" \"13\"\n[25,] \"11\" \"13\"\n[26,] \"3\"  \"14\"\n[27,] \"4\"  \"14\"\n[28,] \"7\"  \"14\"\n[29,] \"7\"  \"15\"\n[30,] \"9\"  \"15\"\n[31,] \"13\" \"15\"\n[32,] \"1\"  \"16\"\n[33,] \"7\"  \"16\"\n[34,] \"11\" \"16\"\n[35,] \"13\" \"16\"\n[36,] \"14\" \"16\"\n[37,] \"1\"  \"17\"\n[38,] \"4\"  \"17\"\n[39,] \"6\"  \"17\"\n[40,] \"7\"  \"17\"\n[41,] \"8\"  \"17\"\n[42,] \"10\" \"17\"\n[43,] \"1\"  \"18\"\n[44,] \"6\"  \"18\"\n[45,] \"15\" \"18\"\n[46,] \"16\" \"18\"\n[47,] \"2\"  \"19\"\n[48,] \"5\"  \"19\"\n[49,] \"6\"  \"19\"\n[50,] \"8\"  \"19\"\n[51,] \"1\"  \"20\"\n[52,] \"3\"  \"20\"\n[53,] \"5\"  \"20\"\n[54,] \"7\"  \"20\"\n[55,] \"8\"  \"20\"\n[56,] \"9\"  \"20\"\n[57,] \"12\" \"20\"\n[58,] \"15\" \"20\"\n[59,] \"17\" \"20\"\n[60,] \"18\" \"20\"\n\nas_adjacency_matrix(red2)\n\n20 x 20 sparse Matrix of class \"dgCMatrix\"\n                                          \n1  . . . 1 . . . 1 1 . . . 1 . . 1 1 1 . 1\n2  . . . 1 1 . . . . . . . . . . . . . 1 .\n3  . . . . . 1 . 1 . . 1 . . 1 . . . . . 1\n4  1 1 . . 1 . . . 1 1 . . . 1 . . 1 . . .\n5  . 1 . 1 . . . . 1 . . 1 . . . . . . 1 1\n6  . . 1 . . . . . . . . . 1 . . . 1 1 1 .\n7  . . . . . . . . . . 1 1 1 1 1 1 1 . . 1\n8  1 . 1 . . . . . 1 . . 1 1 . . . 1 . 1 1\n9  1 . . 1 1 . . 1 . . . 1 . . 1 . . . . 1\n10 . . . 1 . . . . . . 1 . 1 . . . 1 . . .\n11 . . 1 . . . 1 . . 1 . . 1 . . 1 . . . .\n12 . . . . 1 . 1 1 1 . . . . . . . . . . 1\n13 1 . . . . 1 1 1 . 1 1 . . . 1 1 . . . .\n14 . . 1 1 . . 1 . . . . . . . . 1 . . . .\n15 . . . . . . 1 . 1 . . . 1 . . . . 1 . 1\n16 1 . . . . . 1 . . . 1 . 1 1 . . . 1 . .\n17 1 . . 1 . 1 1 1 . 1 . . . . . . . . . 1\n18 1 . . . . 1 . . . . . . . . 1 1 . . . 1\n19 . 1 . . 1 1 . 1 . . . . . . . . . . . .\n20 1 . 1 . 1 . 1 1 1 . . 1 . . 1 . 1 1 . .\n\nas_data_frame(red2, what = \"edges\")\n\n   from to distancia  tipo\n1     1  4         5 tipo5\n2     2  4       103 tipo1\n3     2  5        86 tipo4\n4     4  5        13 tipo1\n5     3  6        43 tipo3\n6     1  8        33 tipo4\n7     3  8        45 tipo1\n8     1  9        67 tipo2\n9     4  9        74 tipo2\n10    5  9        66 tipo4\n11    8  9        67 tipo4\n12    4 10        77 tipo4\n13    3 11        31 tipo1\n14    7 11        60 tipo4\n15   10 11        55 tipo1\n16    5 12        27 tipo4\n17    7 12        35 tipo4\n18    8 12        87 tipo1\n19    9 12        59 tipo2\n20    1 13        41 tipo2\n21    6 13        95 tipo1\n22    7 13        75 tipo4\n23    8 13        75 tipo5\n24   10 13        50 tipo3\n25   11 13        70 tipo5\n26    3 14        67 tipo4\n27    4 14        65 tipo2\n28    7 14        71 tipo1\n29    7 15        80 tipo1\n30    9 15        40 tipo2\n31   13 15        44 tipo2\n32    1 16        83 tipo5\n33    7 16        21 tipo4\n34   11 16        36 tipo3\n35   13 16        51 tipo1\n36   14 16        47 tipo5\n37    1 17        66 tipo4\n38    4 17        87 tipo4\n39    6 17        49 tipo1\n40    7 17        57 tipo3\n41    8 17        54 tipo1\n42   10 17        60 tipo4\n43    1 18        57 tipo2\n44    6 18        61 tipo4\n45   15 18        39 tipo3\n46   16 18        71 tipo3\n47    2 19        44 tipo1\n48    5 19        65 tipo5\n49    6 19        51 tipo4\n50    8 19        21 tipo1\n51    1 20        71 tipo4\n52    3 20        48 tipo1\n53    5 20        82 tipo4\n54    7 20        68 tipo1\n55    8 20        80 tipo5\n56    9 20        65 tipo4\n57   12 20        83 tipo2\n58   15 20        53 tipo2\n59   17 20        66 tipo2\n60   18 20        72 tipo2\nYa creados los objetos de redes, graficarlos es bastante simple y versátil. En el paquete igraph hay 3 funciones que pueden usarse para tal fin:\nEmpecemos usando la opción más común\nplot.igraph(red1)\n\n\n\nplot(red2)\nFácil de graficar, pero el resultado es bastante mejorable (sobretodo para la red dirigida).\nRevisemos los parámetros que podemos modificar a la hora de graficar las redes. los parámetros correspondiente a los vértices se nombran como vertex.nombre_atributo y los correspondientes a las aristas como edge.nombre_atributo. Por ejemplo, vertex.color se refiere al color de los vértices y edge.color se refiere al color de las aristas 🤯\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 30, \n     # vertex.size2 = 40, # para formas como \"rectangle\"\n     vertex.frame.color = \"#2E1D1D\",\n     rescale = T # este es el valor por defecto y es\n                # buena idea dejarlo así\n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 20, \n     vertex.size2 = 30,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3\n     \n     )\nLas opciones para vertex.shape son:\nOtro intento 😥\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 10, \n     vertex.label = NA,\n     vertex.frame.color = \"#2E1D1D\",\n     \n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 10, \n     vertex.size2 = 15,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3,\n     vertex.label.font = 2, # 1: normal, 2: negrilla, 3; itálica\n                            # 4: itálica y negrilla.\n     vertex.label.cex = 0.5,\n     vertex.label.color = \"red\",\n     vertex.label.dist = 2, #distancia del centro\n     vertex.label.degree = pi #0:derecha, pi:izquierda, pi/2 arriba, -pi/2: abajo\n     )\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 10, \n     vertex.label = NA,\n     vertex.frame.color = \"#2E1D1D\",\n     \n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 10, \n     vertex.size2 = 15,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3,\n     vertex.label.font = 2, # 1: normal, 2: negrilla, 3; itálica\n                            # 4: itálica y negrilla.\n     vertex.label.cex = 0.5,\n     vertex.label.color = \"red\",\n     vertex.label.dist = 2, #distancia del centro\n     vertex.label.degree = pi #0:derecha, pi:izquierda, pi/2 arriba, -pi/2: abajo\n     )\n¿Nada? La tercera es la vencida (¡el tercer parcial sí lo ganamos!) 💪. Resaltemos los vértices y aristas por demanda y distancia\nV(red1)$size &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda))\nE(red1)$width &lt;- 5*(E(red1)$distancia/max(E(red1)$distancia))\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\",\n     vertex.label = NA,\n     vertex.frame.width = 1.5,\n     vertex.frame.color = \"#2E1D1D\",\n     edge.color = \"#AEB4A9\",\n     edge.arrow.size = 0.8,\n     edge.arrow.width = 0.8,\n     \n     )\nNote que, la línea V(red1)$size &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda)) agrega un atributo size al conjunto de vértices de la red, de ahí la importancia de colocar el nombre preciso para que sea reconocido en la función plot sin necesidad de volver a declararlo. Es decir que si colocamos V(red1)$size_1 &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda)), no funcionará ya que no hay un atributo para los vértices en la función plot llamdo size_1. La misma aclaración aplica para el atributo de ancho de las aristas (width) en la línea E(red1)$width &lt;- 5*(E(red1)$distancia/max(E(red1)$distancia)).\nAhora poniendo diferentes colores para cada grupo de nodos y tipo de arista\ntable(E(red2)$tipo)\n\n\ntipo1 tipo2 tipo3 tipo4 tipo5 \n   16    12     6    19     7 \n\ntable(V(red2)$grupo)\n\n\ngrupo1 grupo2 grupo3 grupo4 \n     6      5      2      7 \n\nV(red2)$size &lt;- 20*(V(red2)$demanda/max(V(red2)$demanda))\nE(red2)$width &lt;- 5*(E(red2)$distancia/max(E(red2)$distancia))\nvert_color &lt;- c(\"#E66563\", \"#357FBF\", \"#9AAD1F\", \"#237A28\")\nedge_color &lt;- c(\"#CD3278\", \"#EE3B3B\", \"#CD6839\", \"#B452CD\", \"#4169E1\")\n\n\nV(red2)$color &lt;- vert_color[as.factor(V(red2)$grupo)]\nE(red2)$color &lt;- edge_color[as.factor(E(red2)$tipo)]\n\nplot(red2, vertex.color=vert_color, \n     vertex.shape = \"square\", \n     vertex.label = NA,\n     vertex.frame.width = 1.5,\n     vertex.frame.color = \"#2E1D1D\",\n     )"
  },
  {
    "objectID": "index.html#plan-de-trabajo",
    "href": "index.html#plan-de-trabajo",
    "title": "Optimización de redes",
    "section": "Plan de trabajo",
    "text": "Plan de trabajo\n\n\n\n\n\nSemana\nInicio\nTemas\n\n\n\n\n1\njulio 17\nMotivación. Modelación matemática. Problemas de optimización\n\n\n2\njulio 24\nClasificación de problemas y técnicas de optimización. Problemas de redes y aplicaciones\n\n\n3\njulio 31\nGrafos. Definiciones y teoría matemática\n\n\n4\nagosto 07\nVisualización\n\n\n5\nagosto 14\nEstructuras de datos y representación computacional de redes. Examen 1\n\n\n6\nagosto 21\nEstructuras de datos y representación computacional de redes\n\n\n7\nagosto 28\nCaminos y ciclos. Árboles. Complejidad computacional\n\n\n8\nseptiembre 04\nÁrbol de mínima expansión. Teoría, algoritmos y aplicaciones\n\n\n9\nseptiembre 11\nRuta más corta. Teoría, algoritmos y aplicaciones\n\n\n10\nseptiembre 18\nRuta más corta. Teoría, algoritmos y aplicaciones. Examen 2\n\n\n11\nseptiembre 25\nFlujo de costo mínimo\n\n\n12\noctubre 02\nFlujo máximo\n\n\n13\noctubre 09\nAsignación, localización, emparejamiento. Examen 3\n\n\n14\noctubre 16\nRuteo de nodos. Ruteo de arcos\n\n\n15\noctubre 23\nAplicaciones adicionales de redes\n\n\n16\noctubre 30\nAplicaciones adicionales de redes"
  },
  {
    "objectID": "r-visual.html#representación-de-una-red",
    "href": "r-visual.html#representación-de-una-red",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.1 Representación de una red",
    "text": "2.1 Representación de una red\n\nHay varias formas de representar una red. La más común es la de mapa de red que hemos estado haciendo desde el principio, donde los nodos se representan con círculos o puntos y las aristas con líneas entre los nodos, si es una red dirigida, la línea se convierte en una flecha.\nEl tipo de representación a usar, dependerá del objetivo que tengamos en mente. En cualquier caso, lo que se busca es hacer el problema más legible. Y este es uno de los grandes atractivos de los problemas de redes.\nDebemos cuidar algunos aspectos básicos para obtener una buena representación.\n\n\n\nTomado de: https://kateto.net/network-visualization"
  },
  {
    "objectID": "r-visual.html#elementos-clave-al-graficar-una-red",
    "href": "r-visual.html#elementos-clave-al-graficar-una-red",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.2 Elementos clave al graficar una red",
    "text": "2.2 Elementos clave al graficar una red\n\nEntre los conceptos o elementos claves que debemos tener en cuenta a la hora de graficar nuestra red están:\n\nPosición de los nodos\nColores\nForma de nodos y arcos\nDiseño en general\n\nEl layout de la red busca maximizar la estética y legibilidad de lo que queremos comunicar. Algunas cosas a tener en cuenta\n\n\n\nTomado de: https://kateto.net/network-visualization"
  },
  {
    "objectID": "r-visual.html#bonus-colores",
    "href": "r-visual.html#bonus-colores",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.3 Bonus: Colores",
    "text": "2.3 Bonus: Colores\n\nParte importante de nuestra red como gráfica, es el uso de los colores\nEn R podemos manejar colores por nombres (en inglés, por supuesto) o usando sistemas de codificación como el RGB y Hexadecimal\nUna lista de colores en R la podemos obtener con colors()\n\n\n\n\n\n\nN\nColores\n\n\n\n\n1\nwhite\n\n\n2\naliceblue\n\n\n3\nantiquewhite\n\n\n4\nantiquewhite1\n\n\n5\nantiquewhite2\n\n\n6\nantiquewhite3\n\n\n7\nantiquewhite4\n\n\n8\naquamarine\n\n\n9\naquamarine1\n\n\n10\naquamarine2\n\n\n11\naquamarine3\n\n\n12\naquamarine4\n\n\n13\nazure\n\n\n14\nazure1\n\n\n15\nazure2\n\n\n16\nazure3\n\n\n17\nazure4\n\n\n18\nbeige\n\n\n19\nbisque\n\n\n20\nbisque1\n\n\n21\nbisque2\n\n\n22\nbisque3\n\n\n23\nbisque4\n\n\n24\nblack\n\n\n25\nblanchedalmond\n\n\n26\nblue\n\n\n27\nblue1\n\n\n28\nblue2\n\n\n29\nblue3\n\n\n30\nblue4\n\n\n31\nblueviolet\n\n\n32\nbrown\n\n\n33\nbrown1\n\n\n34\nbrown2\n\n\n35\nbrown3\n\n\n36\nbrown4\n\n\n37\nburlywood\n\n\n38\nburlywood1\n\n\n39\nburlywood2\n\n\n40\nburlywood3\n\n\n41\nburlywood4\n\n\n42\ncadetblue\n\n\n43\ncadetblue1\n\n\n44\ncadetblue2\n\n\n45\ncadetblue3\n\n\n46\ncadetblue4\n\n\n47\nchartreuse\n\n\n48\nchartreuse1\n\n\n49\nchartreuse2\n\n\n50\nchartreuse3\n\n\n51\nchartreuse4\n\n\n52\nchocolate\n\n\n53\nchocolate1\n\n\n54\nchocolate2\n\n\n55\nchocolate3\n\n\n56\nchocolate4\n\n\n57\ncoral\n\n\n58\ncoral1\n\n\n59\ncoral2\n\n\n60\ncoral3\n\n\n61\ncoral4\n\n\n62\ncornflowerblue\n\n\n63\ncornsilk\n\n\n64\ncornsilk1\n\n\n65\ncornsilk2\n\n\n66\ncornsilk3\n\n\n67\ncornsilk4\n\n\n68\ncyan\n\n\n69\ncyan1\n\n\n70\ncyan2\n\n\n71\ncyan3\n\n\n72\ncyan4\n\n\n73\ndarkblue\n\n\n74\ndarkcyan\n\n\n75\ndarkgoldenrod\n\n\n76\ndarkgoldenrod1\n\n\n77\ndarkgoldenrod2\n\n\n78\ndarkgoldenrod3\n\n\n79\ndarkgoldenrod4\n\n\n80\ndarkgray\n\n\n81\ndarkgreen\n\n\n82\ndarkgrey\n\n\n83\ndarkkhaki\n\n\n84\ndarkmagenta\n\n\n85\ndarkolivegreen\n\n\n86\ndarkolivegreen1\n\n\n87\ndarkolivegreen2\n\n\n88\ndarkolivegreen3\n\n\n89\ndarkolivegreen4\n\n\n90\ndarkorange\n\n\n91\ndarkorange1\n\n\n92\ndarkorange2\n\n\n93\ndarkorange3\n\n\n94\ndarkorange4\n\n\n95\ndarkorchid\n\n\n96\ndarkorchid1\n\n\n97\ndarkorchid2\n\n\n98\ndarkorchid3\n\n\n99\ndarkorchid4\n\n\n100\ndarkred\n\n\n101\ndarksalmon\n\n\n102\ndarkseagreen\n\n\n103\ndarkseagreen1\n\n\n104\ndarkseagreen2\n\n\n105\ndarkseagreen3\n\n\n106\ndarkseagreen4\n\n\n107\ndarkslateblue\n\n\n108\ndarkslategray\n\n\n109\ndarkslategray1\n\n\n110\ndarkslategray2\n\n\n111\ndarkslategray3\n\n\n112\ndarkslategray4\n\n\n113\ndarkslategrey\n\n\n114\ndarkturquoise\n\n\n115\ndarkviolet\n\n\n116\ndeeppink\n\n\n117\ndeeppink1\n\n\n118\ndeeppink2\n\n\n119\ndeeppink3\n\n\n120\ndeeppink4\n\n\n121\ndeepskyblue\n\n\n122\ndeepskyblue1\n\n\n123\ndeepskyblue2\n\n\n124\ndeepskyblue3\n\n\n125\ndeepskyblue4\n\n\n126\ndimgray\n\n\n127\ndimgrey\n\n\n128\ndodgerblue\n\n\n129\ndodgerblue1\n\n\n130\ndodgerblue2\n\n\n131\ndodgerblue3\n\n\n132\ndodgerblue4\n\n\n133\nfirebrick\n\n\n134\nfirebrick1\n\n\n135\nfirebrick2\n\n\n136\nfirebrick3\n\n\n137\nfirebrick4\n\n\n138\nfloralwhite\n\n\n139\nforestgreen\n\n\n140\ngainsboro\n\n\n141\nghostwhite\n\n\n142\ngold\n\n\n143\ngold1\n\n\n144\ngold2\n\n\n145\ngold3\n\n\n146\ngold4\n\n\n147\ngoldenrod\n\n\n148\ngoldenrod1\n\n\n149\ngoldenrod2\n\n\n150\ngoldenrod3\n\n\n151\ngoldenrod4\n\n\n152\ngray\n\n\n153\ngray0\n\n\n154\ngray1\n\n\n155\ngray2\n\n\n156\ngray3\n\n\n157\ngray4\n\n\n158\ngray5\n\n\n159\ngray6\n\n\n160\ngray7\n\n\n161\ngray8\n\n\n162\ngray9\n\n\n163\ngray10\n\n\n164\ngray11\n\n\n165\ngray12\n\n\n166\ngray13\n\n\n167\ngray14\n\n\n168\ngray15\n\n\n169\ngray16\n\n\n170\ngray17\n\n\n171\ngray18\n\n\n172\ngray19\n\n\n173\ngray20\n\n\n174\ngray21\n\n\n175\ngray22\n\n\n176\ngray23\n\n\n177\ngray24\n\n\n178\ngray25\n\n\n179\ngray26\n\n\n180\ngray27\n\n\n181\ngray28\n\n\n182\ngray29\n\n\n183\ngray30\n\n\n184\ngray31\n\n\n185\ngray32\n\n\n186\ngray33\n\n\n187\ngray34\n\n\n188\ngray35\n\n\n189\ngray36\n\n\n190\ngray37\n\n\n191\ngray38\n\n\n192\ngray39\n\n\n193\ngray40\n\n\n194\ngray41\n\n\n195\ngray42\n\n\n196\ngray43\n\n\n197\ngray44\n\n\n198\ngray45\n\n\n199\ngray46\n\n\n200\ngray47\n\n\n201\ngray48\n\n\n202\ngray49\n\n\n203\ngray50\n\n\n204\ngray51\n\n\n205\ngray52\n\n\n206\ngray53\n\n\n207\ngray54\n\n\n208\ngray55\n\n\n209\ngray56\n\n\n210\ngray57\n\n\n211\ngray58\n\n\n212\ngray59\n\n\n213\ngray60\n\n\n214\ngray61\n\n\n215\ngray62\n\n\n216\ngray63\n\n\n217\ngray64\n\n\n218\ngray65\n\n\n219\ngray66\n\n\n220\ngray67\n\n\n221\ngray68\n\n\n222\ngray69\n\n\n223\ngray70\n\n\n224\ngray71\n\n\n225\ngray72\n\n\n226\ngray73\n\n\n227\ngray74\n\n\n228\ngray75\n\n\n229\ngray76\n\n\n230\ngray77\n\n\n231\ngray78\n\n\n232\ngray79\n\n\n233\ngray80\n\n\n234\ngray81\n\n\n235\ngray82\n\n\n236\ngray83\n\n\n237\ngray84\n\n\n238\ngray85\n\n\n239\ngray86\n\n\n240\ngray87\n\n\n241\ngray88\n\n\n242\ngray89\n\n\n243\ngray90\n\n\n244\ngray91\n\n\n245\ngray92\n\n\n246\ngray93\n\n\n247\ngray94\n\n\n248\ngray95\n\n\n249\ngray96\n\n\n250\ngray97\n\n\n251\ngray98\n\n\n252\ngray99\n\n\n253\ngray100\n\n\n254\ngreen\n\n\n255\ngreen1\n\n\n256\ngreen2\n\n\n257\ngreen3\n\n\n258\ngreen4\n\n\n259\ngreenyellow\n\n\n260\ngrey\n\n\n261\ngrey0\n\n\n262\ngrey1\n\n\n263\ngrey2\n\n\n264\ngrey3\n\n\n265\ngrey4\n\n\n266\ngrey5\n\n\n267\ngrey6\n\n\n268\ngrey7\n\n\n269\ngrey8\n\n\n270\ngrey9\n\n\n271\ngrey10\n\n\n272\ngrey11\n\n\n273\ngrey12\n\n\n274\ngrey13\n\n\n275\ngrey14\n\n\n276\ngrey15\n\n\n277\ngrey16\n\n\n278\ngrey17\n\n\n279\ngrey18\n\n\n280\ngrey19\n\n\n281\ngrey20\n\n\n282\ngrey21\n\n\n283\ngrey22\n\n\n284\ngrey23\n\n\n285\ngrey24\n\n\n286\ngrey25\n\n\n287\ngrey26\n\n\n288\ngrey27\n\n\n289\ngrey28\n\n\n290\ngrey29\n\n\n291\ngrey30\n\n\n292\ngrey31\n\n\n293\ngrey32\n\n\n294\ngrey33\n\n\n295\ngrey34\n\n\n296\ngrey35\n\n\n297\ngrey36\n\n\n298\ngrey37\n\n\n299\ngrey38\n\n\n300\ngrey39\n\n\n301\ngrey40\n\n\n302\ngrey41\n\n\n303\ngrey42\n\n\n304\ngrey43\n\n\n305\ngrey44\n\n\n306\ngrey45\n\n\n307\ngrey46\n\n\n308\ngrey47\n\n\n309\ngrey48\n\n\n310\ngrey49\n\n\n311\ngrey50\n\n\n312\ngrey51\n\n\n313\ngrey52\n\n\n314\ngrey53\n\n\n315\ngrey54\n\n\n316\ngrey55\n\n\n317\ngrey56\n\n\n318\ngrey57\n\n\n319\ngrey58\n\n\n320\ngrey59\n\n\n321\ngrey60\n\n\n322\ngrey61\n\n\n323\ngrey62\n\n\n324\ngrey63\n\n\n325\ngrey64\n\n\n326\ngrey65\n\n\n327\ngrey66\n\n\n328\ngrey67\n\n\n329\ngrey68\n\n\n330\ngrey69\n\n\n331\ngrey70\n\n\n332\ngrey71\n\n\n333\ngrey72\n\n\n334\ngrey73\n\n\n335\ngrey74\n\n\n336\ngrey75\n\n\n337\ngrey76\n\n\n338\ngrey77\n\n\n339\ngrey78\n\n\n340\ngrey79\n\n\n341\ngrey80\n\n\n342\ngrey81\n\n\n343\ngrey82\n\n\n344\ngrey83\n\n\n345\ngrey84\n\n\n346\ngrey85\n\n\n347\ngrey86\n\n\n348\ngrey87\n\n\n349\ngrey88\n\n\n350\ngrey89\n\n\n351\ngrey90\n\n\n352\ngrey91\n\n\n353\ngrey92\n\n\n354\ngrey93\n\n\n355\ngrey94\n\n\n356\ngrey95\n\n\n357\ngrey96\n\n\n358\ngrey97\n\n\n359\ngrey98\n\n\n360\ngrey99\n\n\n361\ngrey100\n\n\n362\nhoneydew\n\n\n363\nhoneydew1\n\n\n364\nhoneydew2\n\n\n365\nhoneydew3\n\n\n366\nhoneydew4\n\n\n367\nhotpink\n\n\n368\nhotpink1\n\n\n369\nhotpink2\n\n\n370\nhotpink3\n\n\n371\nhotpink4\n\n\n372\nindianred\n\n\n373\nindianred1\n\n\n374\nindianred2\n\n\n375\nindianred3\n\n\n376\nindianred4\n\n\n377\nivory\n\n\n378\nivory1\n\n\n379\nivory2\n\n\n380\nivory3\n\n\n381\nivory4\n\n\n382\nkhaki\n\n\n383\nkhaki1\n\n\n384\nkhaki2\n\n\n385\nkhaki3\n\n\n386\nkhaki4\n\n\n387\nlavender\n\n\n388\nlavenderblush\n\n\n389\nlavenderblush1\n\n\n390\nlavenderblush2\n\n\n391\nlavenderblush3\n\n\n392\nlavenderblush4\n\n\n393\nlawngreen\n\n\n394\nlemonchiffon\n\n\n395\nlemonchiffon1\n\n\n396\nlemonchiffon2\n\n\n397\nlemonchiffon3\n\n\n398\nlemonchiffon4\n\n\n399\nlightblue\n\n\n400\nlightblue1\n\n\n401\nlightblue2\n\n\n402\nlightblue3\n\n\n403\nlightblue4\n\n\n404\nlightcoral\n\n\n405\nlightcyan\n\n\n406\nlightcyan1\n\n\n407\nlightcyan2\n\n\n408\nlightcyan3\n\n\n409\nlightcyan4\n\n\n410\nlightgoldenrod\n\n\n411\nlightgoldenrod1\n\n\n412\nlightgoldenrod2\n\n\n413\nlightgoldenrod3\n\n\n414\nlightgoldenrod4\n\n\n415\nlightgoldenrodyellow\n\n\n416\nlightgray\n\n\n417\nlightgreen\n\n\n418\nlightgrey\n\n\n419\nlightpink\n\n\n420\nlightpink1\n\n\n421\nlightpink2\n\n\n422\nlightpink3\n\n\n423\nlightpink4\n\n\n424\nlightsalmon\n\n\n425\nlightsalmon1\n\n\n426\nlightsalmon2\n\n\n427\nlightsalmon3\n\n\n428\nlightsalmon4\n\n\n429\nlightseagreen\n\n\n430\nlightskyblue\n\n\n431\nlightskyblue1\n\n\n432\nlightskyblue2\n\n\n433\nlightskyblue3\n\n\n434\nlightskyblue4\n\n\n435\nlightslateblue\n\n\n436\nlightslategray\n\n\n437\nlightslategrey\n\n\n438\nlightsteelblue\n\n\n439\nlightsteelblue1\n\n\n440\nlightsteelblue2\n\n\n441\nlightsteelblue3\n\n\n442\nlightsteelblue4\n\n\n443\nlightyellow\n\n\n444\nlightyellow1\n\n\n445\nlightyellow2\n\n\n446\nlightyellow3\n\n\n447\nlightyellow4\n\n\n448\nlimegreen\n\n\n449\nlinen\n\n\n450\nmagenta\n\n\n451\nmagenta1\n\n\n452\nmagenta2\n\n\n453\nmagenta3\n\n\n454\nmagenta4\n\n\n455\nmaroon\n\n\n456\nmaroon1\n\n\n457\nmaroon2\n\n\n458\nmaroon3\n\n\n459\nmaroon4\n\n\n460\nmediumaquamarine\n\n\n461\nmediumblue\n\n\n462\nmediumorchid\n\n\n463\nmediumorchid1\n\n\n464\nmediumorchid2\n\n\n465\nmediumorchid3\n\n\n466\nmediumorchid4\n\n\n467\nmediumpurple\n\n\n468\nmediumpurple1\n\n\n469\nmediumpurple2\n\n\n470\nmediumpurple3\n\n\n471\nmediumpurple4\n\n\n472\nmediumseagreen\n\n\n473\nmediumslateblue\n\n\n474\nmediumspringgreen\n\n\n475\nmediumturquoise\n\n\n476\nmediumvioletred\n\n\n477\nmidnightblue\n\n\n478\nmintcream\n\n\n479\nmistyrose\n\n\n480\nmistyrose1\n\n\n481\nmistyrose2\n\n\n482\nmistyrose3\n\n\n483\nmistyrose4\n\n\n484\nmoccasin\n\n\n485\nnavajowhite\n\n\n486\nnavajowhite1\n\n\n487\nnavajowhite2\n\n\n488\nnavajowhite3\n\n\n489\nnavajowhite4\n\n\n490\nnavy\n\n\n491\nnavyblue\n\n\n492\noldlace\n\n\n493\nolivedrab\n\n\n494\nolivedrab1\n\n\n495\nolivedrab2\n\n\n496\nolivedrab3\n\n\n497\nolivedrab4\n\n\n498\norange\n\n\n499\norange1\n\n\n500\norange2\n\n\n501\norange3\n\n\n502\norange4\n\n\n503\norangered\n\n\n504\norangered1\n\n\n505\norangered2\n\n\n506\norangered3\n\n\n507\norangered4\n\n\n508\norchid\n\n\n509\norchid1\n\n\n510\norchid2\n\n\n511\norchid3\n\n\n512\norchid4\n\n\n513\npalegoldenrod\n\n\n514\npalegreen\n\n\n515\npalegreen1\n\n\n516\npalegreen2\n\n\n517\npalegreen3\n\n\n518\npalegreen4\n\n\n519\npaleturquoise\n\n\n520\npaleturquoise1\n\n\n521\npaleturquoise2\n\n\n522\npaleturquoise3\n\n\n523\npaleturquoise4\n\n\n524\npalevioletred\n\n\n525\npalevioletred1\n\n\n526\npalevioletred2\n\n\n527\npalevioletred3\n\n\n528\npalevioletred4\n\n\n529\npapayawhip\n\n\n530\npeachpuff\n\n\n531\npeachpuff1\n\n\n532\npeachpuff2\n\n\n533\npeachpuff3\n\n\n534\npeachpuff4\n\n\n535\nperu\n\n\n536\npink\n\n\n537\npink1\n\n\n538\npink2\n\n\n539\npink3\n\n\n540\npink4\n\n\n541\nplum\n\n\n542\nplum1\n\n\n543\nplum2\n\n\n544\nplum3\n\n\n545\nplum4\n\n\n546\npowderblue\n\n\n547\npurple\n\n\n548\npurple1\n\n\n549\npurple2\n\n\n550\npurple3\n\n\n551\npurple4\n\n\n552\nred\n\n\n553\nred1\n\n\n554\nred2\n\n\n555\nred3\n\n\n556\nred4\n\n\n557\nrosybrown\n\n\n558\nrosybrown1\n\n\n559\nrosybrown2\n\n\n560\nrosybrown3\n\n\n561\nrosybrown4\n\n\n562\nroyalblue\n\n\n563\nroyalblue1\n\n\n564\nroyalblue2\n\n\n565\nroyalblue3\n\n\n566\nroyalblue4\n\n\n567\nsaddlebrown\n\n\n568\nsalmon\n\n\n569\nsalmon1\n\n\n570\nsalmon2\n\n\n571\nsalmon3\n\n\n572\nsalmon4\n\n\n573\nsandybrown\n\n\n574\nseagreen\n\n\n575\nseagreen1\n\n\n576\nseagreen2\n\n\n577\nseagreen3\n\n\n578\nseagreen4\n\n\n579\nseashell\n\n\n580\nseashell1\n\n\n581\nseashell2\n\n\n582\nseashell3\n\n\n583\nseashell4\n\n\n584\nsienna\n\n\n585\nsienna1\n\n\n586\nsienna2\n\n\n587\nsienna3\n\n\n588\nsienna4\n\n\n589\nskyblue\n\n\n590\nskyblue1\n\n\n591\nskyblue2\n\n\n592\nskyblue3\n\n\n593\nskyblue4\n\n\n594\nslateblue\n\n\n595\nslateblue1\n\n\n596\nslateblue2\n\n\n597\nslateblue3\n\n\n598\nslateblue4\n\n\n599\nslategray\n\n\n600\nslategray1\n\n\n601\nslategray2\n\n\n602\nslategray3\n\n\n603\nslategray4\n\n\n604\nslategrey\n\n\n605\nsnow\n\n\n606\nsnow1\n\n\n607\nsnow2\n\n\n608\nsnow3\n\n\n609\nsnow4\n\n\n610\nspringgreen\n\n\n611\nspringgreen1\n\n\n612\nspringgreen2\n\n\n613\nspringgreen3\n\n\n614\nspringgreen4\n\n\n615\nsteelblue\n\n\n616\nsteelblue1\n\n\n617\nsteelblue2\n\n\n618\nsteelblue3\n\n\n619\nsteelblue4\n\n\n620\ntan\n\n\n621\ntan1\n\n\n622\ntan2\n\n\n623\ntan3\n\n\n624\ntan4\n\n\n625\nthistle\n\n\n626\nthistle1\n\n\n627\nthistle2\n\n\n628\nthistle3\n\n\n629\nthistle4\n\n\n630\ntomato\n\n\n631\ntomato1\n\n\n632\ntomato2\n\n\n633\ntomato3\n\n\n634\ntomato4\n\n\n635\nturquoise\n\n\n636\nturquoise1\n\n\n637\nturquoise2\n\n\n638\nturquoise3\n\n\n639\nturquoise4\n\n\n640\nviolet\n\n\n641\nvioletred\n\n\n642\nvioletred1\n\n\n643\nvioletred2\n\n\n644\nvioletred3\n\n\n645\nvioletred4\n\n\n646\nwheat\n\n\n647\nwheat1\n\n\n648\nwheat2\n\n\n649\nwheat3\n\n\n650\nwheat4\n\n\n651\nwhitesmoke\n\n\n652\nyellow\n\n\n653\nyellow1\n\n\n654\nyellow2\n\n\n655\nyellow3\n\n\n656\nyellow4\n\n\n657\nyellowgreen\n\n\n\n\n\n\n\nManejar colores por nombres nos permite recordarlos fácilmente, pero es bastante limitado, a pesar de los más de 600 colores de la lista anterior, no es nada comparado con los más de 16 millones de colores que podemos generar con sistemas como RGB o HEX (aunque tampoco necesitamos tantos colores, ni todas las pantallas pueden generarlos)\n\nn &lt;- 20\ncol.random &lt;- sample(colors(), size = n)\nplot(x = 1:n, y = 1:n, col = col.random, main = \"Algunos colores aleatorios\",\n     xlab = \"\", ylab=\"\", pch = 20, cex = 5)\n\n\n\ncol.random\n\n [1] \"lightsalmon2\" \"darksalmon\"   \"lightpink\"    \"skyblue\"      \"grey14\"      \n [6] \"floralwhite\"  \"springgreen\"  \"maroon3\"      \"grey23\"       \"ghostwhite\"  \n[11] \"gray42\"       \"grey72\"       \"powderblue\"   \"seashell\"     \"mistyrose1\"  \n[16] \"dimgray\"      \"grey40\"       \"mediumpurple\" \"springgreen2\" \"gainsboro\""
  },
  {
    "objectID": "r-visual.html#sistema-rgb-y-hexadecimal",
    "href": "r-visual.html#sistema-rgb-y-hexadecimal",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.4 Sistema RGB y Hexadecimal",
    "text": "2.4 Sistema RGB y Hexadecimal\n\n2.4.1 RGB\n\nIniciales de los colores primarios (en inglés): R: Red; G: Green; B: Blue. Se basa en la combinación de diferentes niveles de intensidad para cada uno de estos colores\nSe representa como una terna, donde cada valor está entre 0 y 255 (también en escala de 0 a 1 o en porcentajes de 0 a 100). Equivalencia de los colores primarios:\n\nRojo: rgb(255, 0, 0)\nVerde: rgb(0, 255, 0)\nAzul: rgb(0, 0, 255)\n\nAlgunos colores en sistema RGB\n\nplot(x = rep(1,3), col = c(rgb(230,50,110, maxColorValue = 255), \n                           rgb(20,50,10, maxColorValue = 100),   \n                           rgb(0.5,0.5,0.7)), \n     main = \"Algunos colores con RGB\",\n     xlab = \"\", ylab=\"\", pch = 20, cex = 10)\n\n\n\n\nPor defecto, la función rgb() en R, tomará como valor máximo de la escala el 1, así que si se está trabajando en la escala 0-255 (lo más usual), es necesario establecer maxColorValue=255\n\n\n\n\n\n\nlos 256 posibles valores para cada componente, pueden producir en total \\(256^3=16777216\\), más de 16 millones de colores!\nEs posible agregar un valor \\(\\alpha\\) de opacidad a los colores\n\nalfa &lt;- seq(5, 255, by = 25)\nplot(x = rep(1,length(alfa)), col = rgb(17, 125, 0, maxColorValue = 255, alpha = alfa), \n     cex = 10, pch = 20, xlab = \"\", ylab = \"\",\n     main = \"Agregar opacidad al color\")\n\n\n\n\n\n\n\n2.4.2 Hexadecimal\n\nEl sistema hexadecimal consta de 6 posiciones 👨‍🏫, las primeras 2 para el rojo, las siguientes para el verde y las últimas para el azul. Cada una de estas varía entre 00 y FF. Equivalencia de los colores primarios:\n\nRojo: #FF0000\nVerde: #00FF00\nAzul: #0000FF\n\nHay una correspondencia uno a uno entre ambos sistemas (RGB y HEX). Al igual que el sistema RGB, se puede agregar una propiedad de opacidad al agregar 2 posiciones más (también entre 00 y FF) al sistema Hexadecimal.\nAlgunos colores en sistema Hexadecimal\n\nplot(x = rep(1,7), col = c(\"#AD504E\", \"#5F9EA0\", \"#009ACD\", \"#435EBF\", \n                           \"#2F5A63\", \"#2F5A63A6\", \"#2F5A6355\"),\n     cex = 10, pch = 20, xlab = \"\", ylab = \"\",\n     main = \"Algunos colores con Hexadecimal\")\n\n\n\n\nLa equivalencia de los colores primarios en los sistemas RGB y Hex, se resume en la imagen\n\n\n\n\nTomado de https://www.w3schools.com/colors/default.asp\n\n\n\nLa función rgb() convierte el código RGB a Hexadecimal. También se puede hacer lo contrario con la función col2rgb()\n\nrgb(255, 0, 0, maxColorValue = 255) # De RGB a Hexadecimal\n\n[1] \"#FF0000\"\n\ncol2rgb(\"#FF0000\") # De Hexadecimal a RGB\n\n      [,1]\nred    255\ngreen    0\nblue     0\n\n\nDado que estamos hablando de colores, sin duda alguna lo más natural y sencillo es verlos en lugar de memorizar códigos. Hay muchas herramientas online que sirven como mezcladores de colores y nos devuelven los respectivos códigos en diferentes sistemas. El tutorial en w3schools es bastante bueno\n\n\n\n\n\n\n\nEn Rstudio podemos instalar el complemento colourPicker con install.packages(\"colourpicker\"). Al hacerlo se activa en el botón Addins un nuevo complemento.\n \nsi desea aprender un poco más sobre este tema tan interesante (opcional), puede visitar el tutorial de w3schools\n\n\nn &lt;- 10\nx &lt;- sample(x = 0:255, size = n)\ny &lt;- sample(x = 0:255, size = n)\nz &lt;- sample(x = 0:255, size = n)\ntab.col &lt;- cbind(x,y,z)\nplot(rep(1,n), col = rgb(tab.col, maxColorValue = 255), pch = 20,\n     cex = 8, main = \"Otro conjunto de colores aleatorios\")\n\n\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n146\n210\n28\n\n\n33\n143\n199\n\n\n187\n109\n239\n\n\n30\n95\n115\n\n\n78\n191\n149\n\n\n35\n223\n84\n\n\n159\n89\n133\n\n\n89\n28\n191\n\n\n64\n87\n196\n\n\n246\n12\n129"
  },
  {
    "objectID": "r-visual.html#hexadecimal",
    "href": "r-visual.html#hexadecimal",
    "title": "2  Construcción y visualización en R",
    "section": "2.5 Hexadecimal",
    "text": "2.5 Hexadecimal\n\nEl sistema hexadecimal consta de 6 posiciones 👨‍🏫, las primeras 2 para el rojo, las siguientes para el verde y las últimas para el azul. Cada una de estas varía entre 00 y FF. Equivalencia de los colores primarios:\n\nRojo: #FF0000\nVerde: #00FF00\nAzul: #0000FF\n\nHay una correspondencia uno a uno entre ambos sistemas (RGB y HEX). Al igual que el sistema RGB, se puede agregar una propiedad de opacidad al agregar 2 posiciones más (también entre 00 y FF) al sistema Hexadecimal.\nAlgunos colores en sistema Hexadecimal\n\n\nplot(x = rep(1,7), col = c(\"#AD504E\", \"#5F9EA0\", \"#009ACD\", \"#435EBF\", \n                           \"#2F5A63\", \"#2F5A63A6\", \"#2F5A6355\"),\n     cex = 10, pch = 20, xlab = \"\", ylab = \"\",\n     main = \"Algunos colores con Hexadecimal\")\n\n\n\n\n\nLa equivalencia de los colores primarios en los sistemas RGB y Hex, se resume en la imagen\n\n\n\n\nTomado de https://www.w3schools.com/colors/default.asp\n\n\n\nLa función rgb() convierte el código RGB a Hexadecimal. También se puede hacer lo contrario con la función col2rgb()\n\n\nrgb(255, 0, 0, maxColorValue = 255) # De RGB a Hexadecimal\n\n[1] \"#FF0000\"\n\ncol2rgb(\"#FF0000\") # De Hexadecimal a RGB\n\n      [,1]\nred    255\ngreen    0\nblue     0\n\n\n\nDado que estamos hablando de colores, sin duda alguna lo más natural y sencillo es verlos en lugar de memorizar códigos. Hay muchas herramientas online que sirven como mezcladores de colores y nos devuelven los respectivos códigos en diferentes sistemas. El tutorial en w3schools es bastante bueno\n\n\n\n\n\n\n\nEn Rstudio podemos instalar el complemento colourPicker con install.packages(\"colourpicker\"). Al hacerlo se activa en el botón Addins un nuevo complemento.\n\n \n\nsi desea aprender un poco más sobre este tema tan interesante (opcional), puede visitar el tutorial de w3schools\n\n\nn &lt;- 10\nx &lt;- sample(x = 0:255, size = n)\ny &lt;- sample(x = 0:255, size = n)\nz &lt;- sample(x = 0:255, size = n)\ntab.col &lt;- cbind(x,y,z)\nplot(rep(1,n), col = rgb(tab.col, maxColorValue = 255), pch = 20,\n     cex = 8, main = \"Otro conjunto de colores aleatorios\")\n\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n146\n210\n28\n\n\n33\n143\n199\n\n\n187\n109\n239\n\n\n30\n95\n115\n\n\n78\n191\n149\n\n\n35\n223\n84\n\n\n159\n89\n133\n\n\n89\n28\n191\n\n\n64\n87\n196\n\n\n246\n12\n129"
  },
  {
    "objectID": "r-visual.html#visualización",
    "href": "r-visual.html#visualización",
    "title": "2  Construcción y visualización en R",
    "section": "2.5 Visualización",
    "text": "2.5 Visualización\n\nCarga de datos\n\nPodemos cargar los datos desde archivos externos. En este caso, tenemos dos archivos de texto que contienen la información de los vértices y aristas de la red que vamos a trabajar como ejemplo. Descargue desde Moodle los archivos: artistas.txt y vertices.txt, y guárdelos en la misma carpeta en donde tiene el script de R\nejecute el siguiente código para cargar los datos en R\n\naristas &lt;- read.table(file = \"aristas.txt\", header = T)\nvertices &lt;- read.table(file = \"vertices.txt\", header = T)\n\nObserve la información en las primeras filas de cada una de estas bases de datos\n\nhead(aristas)\nhead(vertices)\n\n\n\n\n\n\ninicio\nfin\ndistancia\ntipo\n\n\n\n\n1\n4\n5\ntipo5\n\n\n2\n4\n103\ntipo1\n\n\n2\n5\n86\ntipo4\n\n\n4\n5\n13\ntipo1\n\n\n3\n6\n43\ntipo3\n\n\n1\n8\n33\ntipo4\n\n\n\n\n\n\n\n\n\n\nvertice\ndemanda\ngrupo\n\n\n\n\n1\n32\ngrupo1\n\n\n2\n11\ngrupo2\n\n\n3\n19\ngrupo4\n\n\n4\n15\ngrupo4\n\n\n5\n14\ngrupo3\n\n\n6\n20\ngrupo4\n\n\n\n\n\n\n\n\n\nCrear la red\n\nAl crear la red en R se crea un objeto (con el paquete igraph) que guarda toda la información necesaria para hacer gráficas y cálculos. Hay varias funciones que pueden usarse para crear estos, objetos, antes hemos usado la función graph(edges=edges_list) para crear la red a partir de un vector que contiene las aristas como pares de nodos. En este caso, construiremos la red a partir de un data frame con la función graph_from_data_frame(). Esta función requiere un data frame como primer argumento, y las primeras dos columnas deben corresponder a los puntos iniciales y finales de cada arista, respectivamente\n\nlibrary(igraph)\nred1 &lt;- graph_from_data_frame(d = aristas, vertices = vertices, directed = T)\nred2 &lt;- graph_from_data_frame(d = aristas, vertices = vertices, directed = F)\n\nPodemos imprimir la información en cada uno de estos objetos\n\nred1\n\nIGRAPH 0daadc9 DN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), distancia (e/n), tipo\n| (e/c)\n+ edges from 0daadc9 (vertex names):\n [1] 1 -&gt;4  2 -&gt;4  2 -&gt;5  4 -&gt;5  3 -&gt;6  1 -&gt;8  3 -&gt;8  1 -&gt;9  4 -&gt;9  5 -&gt;9 \n[11] 8 -&gt;9  4 -&gt;10 3 -&gt;11 7 -&gt;11 10-&gt;11 5 -&gt;12 7 -&gt;12 8 -&gt;12 9 -&gt;12 1 -&gt;13\n[21] 6 -&gt;13 7 -&gt;13 8 -&gt;13 10-&gt;13 11-&gt;13 3 -&gt;14 4 -&gt;14 7 -&gt;14 7 -&gt;15 9 -&gt;15\n[31] 13-&gt;15 1 -&gt;16 7 -&gt;16 11-&gt;16 13-&gt;16 14-&gt;16 1 -&gt;17 4 -&gt;17 6 -&gt;17 7 -&gt;17\n[41] 8 -&gt;17 10-&gt;17 1 -&gt;18 6 -&gt;18 15-&gt;18 16-&gt;18 2 -&gt;19 5 -&gt;19 6 -&gt;19 8 -&gt;19\n[51] 1 -&gt;20 3 -&gt;20 5 -&gt;20 7 -&gt;20 8 -&gt;20 9 -&gt;20 12-&gt;20 15-&gt;20 17-&gt;20 18-&gt;20\n\nred2\n\nIGRAPH 0dab26e UN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), distancia (e/n), tipo\n| (e/c)\n+ edges from 0dab26e (vertex names):\n [1] 1 --4  2 --4  2 --5  4 --5  3 --6  1 --8  3 --8  1 --9  4 --9  5 --9 \n[11] 8 --9  4 --10 3 --11 7 --11 10--11 5 --12 7 --12 8 --12 9 --12 1 --13\n[21] 6 --13 7 --13 8 --13 10--13 11--13 3 --14 4 --14 7 --14 7 --15 9 --15\n[31] 13--15 1 --16 7 --16 11--16 13--16 14--16 1 --17 4 --17 6 --17 7 --17\n[41] 8 --17 10--17 1 --18 6 --18 15--18 16--18 2 --19 5 --19 6 --19 8 --19\n[51] 1 --20 3 --20 5 --20 7 --20 8 --20 9 --20 12--20 15--20 17--20 18--20\n\n\nCon las funciones E() y V() podemos acceder de manera independiente a las aristas y vértices de cada red. Podemos incluso, agregar nuevos atributos. Por ejemplo\n\nV(red1)$otro_atributo &lt;- runif(n = length(V(red1)))\nred1\n\nIGRAPH 0daadc9 DN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), otro_atributo (v/n),\n| distancia (e/n), tipo (e/c)\n+ edges from 0daadc9 (vertex names):\n [1] 1 -&gt;4  2 -&gt;4  2 -&gt;5  4 -&gt;5  3 -&gt;6  1 -&gt;8  3 -&gt;8  1 -&gt;9  4 -&gt;9  5 -&gt;9 \n[11] 8 -&gt;9  4 -&gt;10 3 -&gt;11 7 -&gt;11 10-&gt;11 5 -&gt;12 7 -&gt;12 8 -&gt;12 9 -&gt;12 1 -&gt;13\n[21] 6 -&gt;13 7 -&gt;13 8 -&gt;13 10-&gt;13 11-&gt;13 3 -&gt;14 4 -&gt;14 7 -&gt;14 7 -&gt;15 9 -&gt;15\n[31] 13-&gt;15 1 -&gt;16 7 -&gt;16 11-&gt;16 13-&gt;16 14-&gt;16 1 -&gt;17 4 -&gt;17 6 -&gt;17 7 -&gt;17\n[41] 8 -&gt;17 10-&gt;17 1 -&gt;18 6 -&gt;18 15-&gt;18 16-&gt;18 2 -&gt;19 5 -&gt;19 6 -&gt;19 8 -&gt;19\n[51] 1 -&gt;20 3 -&gt;20 5 -&gt;20 7 -&gt;20 8 -&gt;20 9 -&gt;20 12-&gt;20 15-&gt;20 17-&gt;20 18-&gt;20\n\n\nPodemos, a partir del objeto de red, extraer varias estructuras de datos tales como:\n\nLista de aristas\nMatriz de adyacencia\nData Frame\n\n\nas_edgelist(red2)\n\n      [,1] [,2]\n [1,] \"1\"  \"4\" \n [2,] \"2\"  \"4\" \n [3,] \"2\"  \"5\" \n [4,] \"4\"  \"5\" \n [5,] \"3\"  \"6\" \n [6,] \"1\"  \"8\" \n [7,] \"3\"  \"8\" \n [8,] \"1\"  \"9\" \n [9,] \"4\"  \"9\" \n[10,] \"5\"  \"9\" \n[11,] \"8\"  \"9\" \n[12,] \"4\"  \"10\"\n[13,] \"3\"  \"11\"\n[14,] \"7\"  \"11\"\n[15,] \"10\" \"11\"\n[16,] \"5\"  \"12\"\n[17,] \"7\"  \"12\"\n[18,] \"8\"  \"12\"\n[19,] \"9\"  \"12\"\n[20,] \"1\"  \"13\"\n[21,] \"6\"  \"13\"\n[22,] \"7\"  \"13\"\n[23,] \"8\"  \"13\"\n[24,] \"10\" \"13\"\n[25,] \"11\" \"13\"\n[26,] \"3\"  \"14\"\n[27,] \"4\"  \"14\"\n[28,] \"7\"  \"14\"\n[29,] \"7\"  \"15\"\n[30,] \"9\"  \"15\"\n[31,] \"13\" \"15\"\n[32,] \"1\"  \"16\"\n[33,] \"7\"  \"16\"\n[34,] \"11\" \"16\"\n[35,] \"13\" \"16\"\n[36,] \"14\" \"16\"\n[37,] \"1\"  \"17\"\n[38,] \"4\"  \"17\"\n[39,] \"6\"  \"17\"\n[40,] \"7\"  \"17\"\n[41,] \"8\"  \"17\"\n[42,] \"10\" \"17\"\n[43,] \"1\"  \"18\"\n[44,] \"6\"  \"18\"\n[45,] \"15\" \"18\"\n[46,] \"16\" \"18\"\n[47,] \"2\"  \"19\"\n[48,] \"5\"  \"19\"\n[49,] \"6\"  \"19\"\n[50,] \"8\"  \"19\"\n[51,] \"1\"  \"20\"\n[52,] \"3\"  \"20\"\n[53,] \"5\"  \"20\"\n[54,] \"7\"  \"20\"\n[55,] \"8\"  \"20\"\n[56,] \"9\"  \"20\"\n[57,] \"12\" \"20\"\n[58,] \"15\" \"20\"\n[59,] \"17\" \"20\"\n[60,] \"18\" \"20\"\n\nas_adjacency_matrix(red2)\n\n20 x 20 sparse Matrix of class \"dgCMatrix\"\n                                          \n1  . . . 1 . . . 1 1 . . . 1 . . 1 1 1 . 1\n2  . . . 1 1 . . . . . . . . . . . . . 1 .\n3  . . . . . 1 . 1 . . 1 . . 1 . . . . . 1\n4  1 1 . . 1 . . . 1 1 . . . 1 . . 1 . . .\n5  . 1 . 1 . . . . 1 . . 1 . . . . . . 1 1\n6  . . 1 . . . . . . . . . 1 . . . 1 1 1 .\n7  . . . . . . . . . . 1 1 1 1 1 1 1 . . 1\n8  1 . 1 . . . . . 1 . . 1 1 . . . 1 . 1 1\n9  1 . . 1 1 . . 1 . . . 1 . . 1 . . . . 1\n10 . . . 1 . . . . . . 1 . 1 . . . 1 . . .\n11 . . 1 . . . 1 . . 1 . . 1 . . 1 . . . .\n12 . . . . 1 . 1 1 1 . . . . . . . . . . 1\n13 1 . . . . 1 1 1 . 1 1 . . . 1 1 . . . .\n14 . . 1 1 . . 1 . . . . . . . . 1 . . . .\n15 . . . . . . 1 . 1 . . . 1 . . . . 1 . 1\n16 1 . . . . . 1 . . . 1 . 1 1 . . . 1 . .\n17 1 . . 1 . 1 1 1 . 1 . . . . . . . . . 1\n18 1 . . . . 1 . . . . . . . . 1 1 . . . 1\n19 . 1 . . 1 1 . 1 . . . . . . . . . . . .\n20 1 . 1 . 1 . 1 1 1 . . 1 . . 1 . 1 1 . .\n\nas_data_frame(red2, what = \"edges\")\n\n   from to distancia  tipo\n1     1  4         5 tipo5\n2     2  4       103 tipo1\n3     2  5        86 tipo4\n4     4  5        13 tipo1\n5     3  6        43 tipo3\n6     1  8        33 tipo4\n7     3  8        45 tipo1\n8     1  9        67 tipo2\n9     4  9        74 tipo2\n10    5  9        66 tipo4\n11    8  9        67 tipo4\n12    4 10        77 tipo4\n13    3 11        31 tipo1\n14    7 11        60 tipo4\n15   10 11        55 tipo1\n16    5 12        27 tipo4\n17    7 12        35 tipo4\n18    8 12        87 tipo1\n19    9 12        59 tipo2\n20    1 13        41 tipo2\n21    6 13        95 tipo1\n22    7 13        75 tipo4\n23    8 13        75 tipo5\n24   10 13        50 tipo3\n25   11 13        70 tipo5\n26    3 14        67 tipo4\n27    4 14        65 tipo2\n28    7 14        71 tipo1\n29    7 15        80 tipo1\n30    9 15        40 tipo2\n31   13 15        44 tipo2\n32    1 16        83 tipo5\n33    7 16        21 tipo4\n34   11 16        36 tipo3\n35   13 16        51 tipo1\n36   14 16        47 tipo5\n37    1 17        66 tipo4\n38    4 17        87 tipo4\n39    6 17        49 tipo1\n40    7 17        57 tipo3\n41    8 17        54 tipo1\n42   10 17        60 tipo4\n43    1 18        57 tipo2\n44    6 18        61 tipo4\n45   15 18        39 tipo3\n46   16 18        71 tipo3\n47    2 19        44 tipo1\n48    5 19        65 tipo5\n49    6 19        51 tipo4\n50    8 19        21 tipo1\n51    1 20        71 tipo4\n52    3 20        48 tipo1\n53    5 20        82 tipo4\n54    7 20        68 tipo1\n55    8 20        80 tipo5\n56    9 20        65 tipo4\n57   12 20        83 tipo2\n58   15 20        53 tipo2\n59   17 20        66 tipo2\n60   18 20        72 tipo2\n\n\n\n\nGraficar l a red\n\nYa creados los objetos de redes, graficarlos es bastante simple y versátil. En el paquete igraph hay 3 funciones que pueden usarse para tal fin:\n\nplot.igraph() Crea gráficas 2D no interactivas, puede simplemente usarse plot\ntkplot() Produce gráficos 2D interactivos\nrglplot() Crea redes interactivas en 3D\n\nEmpecemos usando la opción más común\n\nplot.igraph(red1)\n\n\n\nplot(red2)\n\n\n\n\nFácil de graficar, pero el resultado es bastante mejorable (sobretodo para la red dirigida).\n\n\nParámetros del gráfico\n\nRevisemos los parámetros que podemos modificar a la hora de graficar las redes. los parámetros correspondiente a los vértices se nombran como vertex.nombre_atributo y los correspondientes a las aristas como edge.nombre_atributo. Por ejemplo, vertex.color se refiere al color de los vértices y edge.color se refiere al color de las aristas 🤯\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 30, \n     # vertex.size2 = 40, # para formas como \"rectangle\"\n     vertex.frame.color = \"#2E1D1D\",\n     rescale = T # este es el valor por defecto y es\n                # buena idea dejarlo así\n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 20, \n     vertex.size2 = 30,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3\n     \n     )\n\n\n\n\nLas opciones para vertex.shape son:\n\nnone\ncircle\nsquare\ncsquare\nrectangle\ncrectangle\nvrectangle\npie\nraster\nsphere\n\nOtro intento 😥\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 10, \n     vertex.label = NA,\n     vertex.frame.color = \"#2E1D1D\",\n     \n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 10, \n     vertex.size2 = 15,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3,\n     vertex.label.font = 2, # 1: normal, 2: negrilla, 3; itálica\n                            # 4: itálica y negrilla.\n     vertex.label.cex = 0.5,\n     vertex.label.color = \"red\",\n     vertex.label.dist = 2, #distancia del centro\n     vertex.label.degree = pi #0:derecha, pi:izquierda, pi/2 arriba, -pi/2: abajo\n     )\n\n\n\n\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 10, \n     vertex.label = NA,\n     vertex.frame.color = \"#2E1D1D\",\n     \n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 10, \n     vertex.size2 = 15,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3,\n     vertex.label.font = 2, # 1: normal, 2: negrilla, 3; itálica\n                            # 4: itálica y negrilla.\n     vertex.label.cex = 0.5,\n     vertex.label.color = \"red\",\n     vertex.label.dist = 2, #distancia del centro\n     vertex.label.degree = pi #0:derecha, pi:izquierda, pi/2 arriba, -pi/2: abajo\n     )\n\n\n\n\n¿Nada? La tercera es la vencida (¡el tercer parcial sí lo ganamos!) 💪. Resaltemos los vértices y aristas por demanda y distancia\n\nV(red1)$size &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda))\nE(red1)$width &lt;- 5*(E(red1)$distancia/max(E(red1)$distancia))\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\",\n     vertex.label = NA,\n     vertex.frame.width = 1.5,\n     vertex.frame.color = \"#2E1D1D\",\n     edge.color = \"#AEB4A9\",\n     edge.arrow.size = 0.8,\n     edge.arrow.width = 0.8,\n     \n     )\n\n\n\n\nNote que, la línea V(red1)$size &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda)) agrega un atributo size al conjunto de vértices de la red, de ahí la importancia de colocar el nombre preciso para que sea reconocido en la función plot sin necesidad de volver a declararlo. Es decir que si colocamos V(red1)$size_1 &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda)), no funcionará ya que no hay un atributo para los vértices en la función plot llamdo size_1. La misma aclaración aplica para el atributo de ancho de las aristas (width) en la línea E(red1)$width &lt;- 5*(E(red1)$distancia/max(E(red1)$distancia)).\nAhora poniendo diferentes colores para cada grupo de nodos y tipo de arista\n\ntable(E(red2)$tipo)\n\n\ntipo1 tipo2 tipo3 tipo4 tipo5 \n   16    12     6    19     7 \n\ntable(V(red2)$grupo)\n\n\ngrupo1 grupo2 grupo3 grupo4 \n     6      5      2      7 \n\nV(red2)$size &lt;- 20*(V(red2)$demanda/max(V(red2)$demanda))\nE(red2)$width &lt;- 5*(E(red2)$distancia/max(E(red2)$distancia))\nvert_color &lt;- c(\"#E66563\", \"#357FBF\", \"#9AAD1F\", \"#237A28\")\nedge_color &lt;- c(\"#CD3278\", \"#EE3B3B\", \"#CD6839\", \"#B452CD\", \"#4169E1\")\n\n\nV(red2)$color &lt;- vert_color[as.factor(V(red2)$grupo)]\nE(red2)$color &lt;- edge_color[as.factor(E(red2)$tipo)]\n\nplot(red2, vertex.color=vert_color, \n     vertex.shape = \"square\", \n     vertex.label = NA,\n     vertex.frame.width = 1.5,\n     vertex.frame.color = \"#2E1D1D\",\n     )\n\n\n\n\n\n\n\n\nAhuja, Ravindra K, Thomas L Magnanti, y James B Orlin. 1995. Network Flows: Theory, Algorithms and Applications. Prentice Hall.\n\n\nBazaraa, Mokhtar S., John J. Jarvis, y Hanif D. Sherali. 2011. Linear Programming and Network Flows. Wiley-Interscience.\n\n\nChen, Wai-Kai. 1990. «Theory of Nets: Flows in Networks».\n\n\nChen, Yunran. 2019. «Introduction to Network Analysis Using R». https://yunranchen.github.io/intro-net-r/index.html.\n\n\nDeo, Narsingh. 2017. Graph Theory with Applications to Engineering and Computer Science. Courier Dover Publications.\n\n\nEvans, James R, y Edward Minieka. 1992. Optimization Algorithms for Networks and Graphs. CRC Press.\n\n\nRao, Singiresu S. 2009. Engineering Optimization: Theory and Practice: Fourth Edition. Engineering Optimization: Theory and Practice: Fourth Edition.\n\n\nRay, Santanu Saha. 2013. Graph Theory with Algorithms and its Applications: in Applied Science and Technology. Springer.\n\n\nSierksma, Gerard, y Diptesh Ghosh. 2010. Networks in Action: Text and Computer Exercises in Network Optimization. Springer."
  },
  {
    "objectID": "r-visual.html#importar-los-datos",
    "href": "r-visual.html#importar-los-datos",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.5 Importar los datos",
    "text": "2.5 Importar los datos\nPodemos cargar los datos desde archivos externos. En este caso, tenemos dos archivos de texto que contienen la información de los vértices y aristas de la red que vamos a trabajar como ejemplo. Descargue desde Moodle los archivos: artistas.txt y vertices.txt, y guárdelos en la misma carpeta en donde tiene el script de R. Verifique que el directorio de trabajo de su sesión actual de R sea la carpeta donde se encuentran los archivos de texto, use getwd().\nejecute el siguiente código para cargar los datos en R\n\naristas &lt;- read.table(file = \"aristas.txt\", header = T)\nvertices &lt;- read.table(file = \"vertices.txt\", header = T)\n\nObserve la información en las primeras filas de cada una de estas bases de datos\n\n\nhead(aristas)\nhead(vertices)\n\n\n\n\n\n\n\n\ninicio\nfin\ndistancia\ntipo\n\n\n\n\n1\n4\n5\ntipo5\n\n\n2\n4\n103\ntipo1\n\n\n2\n5\n86\ntipo4\n\n\n4\n5\n13\ntipo1\n\n\n3\n6\n43\ntipo3\n\n\n1\n8\n33\ntipo4\n\n\n\n\n\n\n\n\n\n\nvertice\ndemanda\ngrupo\n\n\n\n\n1\n32\ngrupo1\n\n\n2\n11\ngrupo2\n\n\n3\n19\ngrupo4\n\n\n4\n15\ngrupo4\n\n\n5\n14\ngrupo3\n\n\n6\n20\ngrupo4"
  },
  {
    "objectID": "r-visual.html#crear-la-red",
    "href": "r-visual.html#crear-la-red",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.6 Crear la red",
    "text": "2.6 Crear la red\nAl crear la red en R (con igraph) se crea un objeto que guarda toda la información necesaria para hacer gráficas y cálculos. Hay varias funciones que pueden usarse para crear estos objetos, antes hemos usado la función graph(edges=edges_list) para crear la red a partir de un vector que contiene las aristas como pares de nodos. En este caso, construiremos la red a partir de un data frame con la función graph_from_data_frame(). Esta función requiere un data frame como primer argumento, y las primeras dos columnas deben corresponder a los puntos iniciales y finales de cada arista, respectivamente\n\nlibrary(igraph)\nred1 &lt;- graph_from_data_frame(d = aristas, vertices = vertices, directed = T)\nred2 &lt;- graph_from_data_frame(d = aristas, vertices = vertices, directed = F)\n\nPodemos imprimir la información en cada uno de estos objetos\n\nred1\n\nIGRAPH 75350c7 DN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), distancia (e/n), tipo\n| (e/c)\n+ edges from 75350c7 (vertex names):\n [1] 1 -&gt;4  2 -&gt;4  2 -&gt;5  4 -&gt;5  3 -&gt;6  1 -&gt;8  3 -&gt;8  1 -&gt;9  4 -&gt;9  5 -&gt;9 \n[11] 8 -&gt;9  4 -&gt;10 3 -&gt;11 7 -&gt;11 10-&gt;11 5 -&gt;12 7 -&gt;12 8 -&gt;12 9 -&gt;12 1 -&gt;13\n[21] 6 -&gt;13 7 -&gt;13 8 -&gt;13 10-&gt;13 11-&gt;13 3 -&gt;14 4 -&gt;14 7 -&gt;14 7 -&gt;15 9 -&gt;15\n[31] 13-&gt;15 1 -&gt;16 7 -&gt;16 11-&gt;16 13-&gt;16 14-&gt;16 1 -&gt;17 4 -&gt;17 6 -&gt;17 7 -&gt;17\n[41] 8 -&gt;17 10-&gt;17 1 -&gt;18 6 -&gt;18 15-&gt;18 16-&gt;18 2 -&gt;19 5 -&gt;19 6 -&gt;19 8 -&gt;19\n[51] 1 -&gt;20 3 -&gt;20 5 -&gt;20 7 -&gt;20 8 -&gt;20 9 -&gt;20 12-&gt;20 15-&gt;20 17-&gt;20 18-&gt;20\n\nred2\n\nIGRAPH 7535ded UN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), distancia (e/n), tipo\n| (e/c)\n+ edges from 7535ded (vertex names):\n [1] 1 --4  2 --4  2 --5  4 --5  3 --6  1 --8  3 --8  1 --9  4 --9  5 --9 \n[11] 8 --9  4 --10 3 --11 7 --11 10--11 5 --12 7 --12 8 --12 9 --12 1 --13\n[21] 6 --13 7 --13 8 --13 10--13 11--13 3 --14 4 --14 7 --14 7 --15 9 --15\n[31] 13--15 1 --16 7 --16 11--16 13--16 14--16 1 --17 4 --17 6 --17 7 --17\n[41] 8 --17 10--17 1 --18 6 --18 15--18 16--18 2 --19 5 --19 6 --19 8 --19\n[51] 1 --20 3 --20 5 --20 7 --20 8 --20 9 --20 12--20 15--20 17--20 18--20\n\n\nCon las funciones E() y V() podemos acceder de manera independiente a las aristas y vértices de cada red. Podemos incluso, agregar nuevos atributos. Por ejemplo\n\nV(red1)$otro_atributo &lt;- runif(n = length(V(red1)))\nred1\n\nIGRAPH 75350c7 DN-- 20 60 -- \n+ attr: name (v/c), demanda (v/n), grupo (v/c), otro_atributo (v/n),\n| distancia (e/n), tipo (e/c)\n+ edges from 75350c7 (vertex names):\n [1] 1 -&gt;4  2 -&gt;4  2 -&gt;5  4 -&gt;5  3 -&gt;6  1 -&gt;8  3 -&gt;8  1 -&gt;9  4 -&gt;9  5 -&gt;9 \n[11] 8 -&gt;9  4 -&gt;10 3 -&gt;11 7 -&gt;11 10-&gt;11 5 -&gt;12 7 -&gt;12 8 -&gt;12 9 -&gt;12 1 -&gt;13\n[21] 6 -&gt;13 7 -&gt;13 8 -&gt;13 10-&gt;13 11-&gt;13 3 -&gt;14 4 -&gt;14 7 -&gt;14 7 -&gt;15 9 -&gt;15\n[31] 13-&gt;15 1 -&gt;16 7 -&gt;16 11-&gt;16 13-&gt;16 14-&gt;16 1 -&gt;17 4 -&gt;17 6 -&gt;17 7 -&gt;17\n[41] 8 -&gt;17 10-&gt;17 1 -&gt;18 6 -&gt;18 15-&gt;18 16-&gt;18 2 -&gt;19 5 -&gt;19 6 -&gt;19 8 -&gt;19\n[51] 1 -&gt;20 3 -&gt;20 5 -&gt;20 7 -&gt;20 8 -&gt;20 9 -&gt;20 12-&gt;20 15-&gt;20 17-&gt;20 18-&gt;20\n\n\nPodemos, a partir del objeto de red, extraer varias estructuras de datos tales como:\n\nLista de aristas\nMatriz de adyacencia\nData Frame\n\n\nas_edgelist(red2)\n\n      [,1] [,2]\n [1,] \"1\"  \"4\" \n [2,] \"2\"  \"4\" \n [3,] \"2\"  \"5\" \n [4,] \"4\"  \"5\" \n [5,] \"3\"  \"6\" \n [6,] \"1\"  \"8\" \n [7,] \"3\"  \"8\" \n [8,] \"1\"  \"9\" \n [9,] \"4\"  \"9\" \n[10,] \"5\"  \"9\" \n[11,] \"8\"  \"9\" \n[12,] \"4\"  \"10\"\n[13,] \"3\"  \"11\"\n[14,] \"7\"  \"11\"\n[15,] \"10\" \"11\"\n[16,] \"5\"  \"12\"\n[17,] \"7\"  \"12\"\n[18,] \"8\"  \"12\"\n[19,] \"9\"  \"12\"\n[20,] \"1\"  \"13\"\n[21,] \"6\"  \"13\"\n[22,] \"7\"  \"13\"\n[23,] \"8\"  \"13\"\n[24,] \"10\" \"13\"\n[25,] \"11\" \"13\"\n[26,] \"3\"  \"14\"\n[27,] \"4\"  \"14\"\n[28,] \"7\"  \"14\"\n[29,] \"7\"  \"15\"\n[30,] \"9\"  \"15\"\n[31,] \"13\" \"15\"\n[32,] \"1\"  \"16\"\n[33,] \"7\"  \"16\"\n[34,] \"11\" \"16\"\n[35,] \"13\" \"16\"\n[36,] \"14\" \"16\"\n[37,] \"1\"  \"17\"\n[38,] \"4\"  \"17\"\n[39,] \"6\"  \"17\"\n[40,] \"7\"  \"17\"\n[41,] \"8\"  \"17\"\n[42,] \"10\" \"17\"\n[43,] \"1\"  \"18\"\n[44,] \"6\"  \"18\"\n[45,] \"15\" \"18\"\n[46,] \"16\" \"18\"\n[47,] \"2\"  \"19\"\n[48,] \"5\"  \"19\"\n[49,] \"6\"  \"19\"\n[50,] \"8\"  \"19\"\n[51,] \"1\"  \"20\"\n[52,] \"3\"  \"20\"\n[53,] \"5\"  \"20\"\n[54,] \"7\"  \"20\"\n[55,] \"8\"  \"20\"\n[56,] \"9\"  \"20\"\n[57,] \"12\" \"20\"\n[58,] \"15\" \"20\"\n[59,] \"17\" \"20\"\n[60,] \"18\" \"20\"\n\nas_adjacency_matrix(red2)\n\n20 x 20 sparse Matrix of class \"dgCMatrix\"\n                                          \n1  . . . 1 . . . 1 1 . . . 1 . . 1 1 1 . 1\n2  . . . 1 1 . . . . . . . . . . . . . 1 .\n3  . . . . . 1 . 1 . . 1 . . 1 . . . . . 1\n4  1 1 . . 1 . . . 1 1 . . . 1 . . 1 . . .\n5  . 1 . 1 . . . . 1 . . 1 . . . . . . 1 1\n6  . . 1 . . . . . . . . . 1 . . . 1 1 1 .\n7  . . . . . . . . . . 1 1 1 1 1 1 1 . . 1\n8  1 . 1 . . . . . 1 . . 1 1 . . . 1 . 1 1\n9  1 . . 1 1 . . 1 . . . 1 . . 1 . . . . 1\n10 . . . 1 . . . . . . 1 . 1 . . . 1 . . .\n11 . . 1 . . . 1 . . 1 . . 1 . . 1 . . . .\n12 . . . . 1 . 1 1 1 . . . . . . . . . . 1\n13 1 . . . . 1 1 1 . 1 1 . . . 1 1 . . . .\n14 . . 1 1 . . 1 . . . . . . . . 1 . . . .\n15 . . . . . . 1 . 1 . . . 1 . . . . 1 . 1\n16 1 . . . . . 1 . . . 1 . 1 1 . . . 1 . .\n17 1 . . 1 . 1 1 1 . 1 . . . . . . . . . 1\n18 1 . . . . 1 . . . . . . . . 1 1 . . . 1\n19 . 1 . . 1 1 . 1 . . . . . . . . . . . .\n20 1 . 1 . 1 . 1 1 1 . . 1 . . 1 . 1 1 . .\n\nas_data_frame(red2, what = \"edges\")\n\n   from to distancia  tipo\n1     1  4         5 tipo5\n2     2  4       103 tipo1\n3     2  5        86 tipo4\n4     4  5        13 tipo1\n5     3  6        43 tipo3\n6     1  8        33 tipo4\n7     3  8        45 tipo1\n8     1  9        67 tipo2\n9     4  9        74 tipo2\n10    5  9        66 tipo4\n11    8  9        67 tipo4\n12    4 10        77 tipo4\n13    3 11        31 tipo1\n14    7 11        60 tipo4\n15   10 11        55 tipo1\n16    5 12        27 tipo4\n17    7 12        35 tipo4\n18    8 12        87 tipo1\n19    9 12        59 tipo2\n20    1 13        41 tipo2\n21    6 13        95 tipo1\n22    7 13        75 tipo4\n23    8 13        75 tipo5\n24   10 13        50 tipo3\n25   11 13        70 tipo5\n26    3 14        67 tipo4\n27    4 14        65 tipo2\n28    7 14        71 tipo1\n29    7 15        80 tipo1\n30    9 15        40 tipo2\n31   13 15        44 tipo2\n32    1 16        83 tipo5\n33    7 16        21 tipo4\n34   11 16        36 tipo3\n35   13 16        51 tipo1\n36   14 16        47 tipo5\n37    1 17        66 tipo4\n38    4 17        87 tipo4\n39    6 17        49 tipo1\n40    7 17        57 tipo3\n41    8 17        54 tipo1\n42   10 17        60 tipo4\n43    1 18        57 tipo2\n44    6 18        61 tipo4\n45   15 18        39 tipo3\n46   16 18        71 tipo3\n47    2 19        44 tipo1\n48    5 19        65 tipo5\n49    6 19        51 tipo4\n50    8 19        21 tipo1\n51    1 20        71 tipo4\n52    3 20        48 tipo1\n53    5 20        82 tipo4\n54    7 20        68 tipo1\n55    8 20        80 tipo5\n56    9 20        65 tipo4\n57   12 20        83 tipo2\n58   15 20        53 tipo2\n59   17 20        66 tipo2\n60   18 20        72 tipo2"
  },
  {
    "objectID": "r-visual.html#graficar-la-red",
    "href": "r-visual.html#graficar-la-red",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.7 Graficar la red",
    "text": "2.7 Graficar la red\nYa creados los objetos de redes, graficarlos es bastante simple y versátil. En el paquete igraph hay 3 funciones que pueden usarse para tal fin:\n\nplot.igraph() Crea gráficas 2D no interactivas, puede simplemente usarse plot\ntkplot() Produce gráficos 2D interactivos\nrglplot() Crea redes interactivas en 3D\n\nEmpecemos usando la opción más común\n\nplot.igraph(red1)\n\n\n\nplot(red2)\n\n\n\n\nFácil de graficar, pero el resultado es bastante mejorable (sobretodo para la red dirigida)."
  },
  {
    "objectID": "r-visual.html#parámetros-del-gráfico",
    "href": "r-visual.html#parámetros-del-gráfico",
    "title": "2  Construcción y visualización de redes con igraph",
    "section": "2.8 Parámetros del gráfico",
    "text": "2.8 Parámetros del gráfico\nRevisemos los parámetros que podemos modificar a la hora de graficar las redes. los parámetros correspondiente a los vértices se nombran como vertex.nombre_atributo y los correspondientes a las aristas como edge.nombre_atributo. Por ejemplo, vertex.color se refiere al color de los vértices y edge.color se refiere al color de las aristas 🤯\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 30, \n     # vertex.size2 = 40, # para formas como \"rectangle\"\n     vertex.frame.color = \"#2E1D1D\",\n     rescale = T # este es el valor por defecto y es\n                # buena idea dejarlo así\n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 20, \n     vertex.size2 = 30,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3\n     \n     )\n\n\n\n\nLas opciones para vertex.shape son:\n\nnone\ncircle\nsquare\ncsquare\nrectangle\ncrectangle\nvrectangle\npie\nraster\nsphere\n\nOtro intento 😥\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 10, \n     vertex.label = NA,\n     vertex.frame.color = \"#2E1D1D\",\n     \n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 10, \n     vertex.size2 = 15,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3,\n     vertex.label.font = 2, # 1: normal, 2: negrilla, 3; itálica\n                            # 4: itálica y negrilla.\n     vertex.label.cex = 0.5,\n     vertex.label.color = \"red\",\n     vertex.label.dist = 2, #distancia del centro\n     vertex.label.degree = pi #0:derecha, pi:izquierda, pi/2 arriba, -pi/2: abajo\n     )\n\n\n\n\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\", \n     vertex.size = 10, \n     vertex.label = NA,\n     vertex.frame.color = \"#2E1D1D\",\n     \n     )\n\n\n\nplot(red2, vertex.color=\"#43A6F2C9\", \n     vertex.shape = \"rectangle\", \n     vertex.size = 10, \n     vertex.size2 = 15,\n     vertex.frame.color = \"#2E1D1D\",\n     vertex.frame.width = 3,\n     vertex.label.font = 2, # 1: normal, 2: negrilla, 3; itálica\n                            # 4: itálica y negrilla.\n     vertex.label.cex = 0.5,\n     vertex.label.color = \"red\",\n     vertex.label.dist = 2, #distancia del centro\n     vertex.label.degree = pi #0:derecha, pi:izquierda, pi/2 arriba, -pi/2: abajo\n     )\n\n\n\n\n¿Nada? ¡La tercera es la vencida! 💪. Resaltemos los vértices y aristas por demanda y distancia\n\nV(red1)$size &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda))\nE(red1)$width &lt;- 5*(E(red1)$distancia/max(E(red1)$distancia))\n\nplot(red1, vertex.color=\"#D582E0B5\", \n     vertex.shape = \"square\",\n     vertex.label = NA,\n     vertex.frame.width = 1.5,\n     vertex.frame.color = \"#2E1D1D\",\n     edge.color = \"#AEB4A9\",\n     edge.arrow.size = 0.8,\n     edge.arrow.width = 0.8,\n     \n     )\n\n\n\n\nNote que, la línea V(red1)$size &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda)) agrega un atributo size al conjunto de vértices de la red, de ahí la importancia de colocar el nombre preciso para que sea reconocido en la función plot sin necesidad de volver a declararlo. Es decir que si colocamos V(red1)$size_1 &lt;- 20*(V(red1)$demanda/max(V(red1)$demanda)), no funcionará ya que no hay un atributo para los vértices en la función plot llamado size_1. La misma aclaración aplica para el atributo de ancho de las aristas (width) en la línea E(red1)$width &lt;- 5*(E(red1)$distancia/max(E(red1)$distancia)).\nAhora poniendo diferentes colores para cada grupo de nodos y tipo de arista\n\ntable(E(red2)$tipo)\n\n\ntipo1 tipo2 tipo3 tipo4 tipo5 \n   16    12     6    19     7 \n\ntable(V(red2)$grupo)\n\n\ngrupo1 grupo2 grupo3 grupo4 \n     6      5      2      7 \n\nV(red2)$size &lt;- 20*(V(red2)$demanda/max(V(red2)$demanda))\nE(red2)$width &lt;- 5*(E(red2)$distancia/max(E(red2)$distancia))\nvert_color &lt;- c(\"#E66563\", \"#357FBF\", \"#9AAD1F\", \"#237A28\")\nedge_color &lt;- c(\"#CD3278\", \"#EE3B3B\", \"#CD6839\", \"#B452CD\", \"#4169E1\")\n\n\nV(red2)$color &lt;- vert_color[as.factor(V(red2)$grupo)]\nE(red2)$color &lt;- edge_color[as.factor(E(red2)$tipo)]\n\nplot(red2, vertex.color=vert_color, \n     vertex.shape = \"square\", \n     vertex.label = NA,\n     vertex.frame.width = 1.5,\n     vertex.frame.color = \"#2E1D1D\",\n     )\n\n\n\n\n\n\n\n\nAhuja, Ravindra K, Thomas L Magnanti, y James B Orlin. 1995. Network Flows: Theory, Algorithms and Applications. Prentice Hall.\n\n\nBazaraa, Mokhtar S., John J. Jarvis, y Hanif D. Sherali. 2011. Linear Programming and Network Flows. Wiley-Interscience.\n\n\nChen, Wai-Kai. 1990. «Theory of Nets: Flows in Networks».\n\n\nChen, Yunran. 2019. «Introduction to Network Analysis Using R». https://yunranchen.github.io/intro-net-r/index.html.\n\n\nDeo, Narsingh. 2017. Graph Theory with Applications to Engineering and Computer Science. Courier Dover Publications.\n\n\nEvans, James R, y Edward Minieka. 1992. Optimization Algorithms for Networks and Graphs. CRC Press.\n\n\nRao, Singiresu S. 2009. Engineering Optimization: Theory and Practice: Fourth Edition. Engineering Optimization: Theory and Practice: Fourth Edition.\n\n\nRay, Santanu Saha. 2013. Graph Theory with Algorithms and its Applications: in Applied Science and Technology. Springer.\n\n\nSierksma, Gerard, y Diptesh Ghosh. 2010. Networks in Action: Text and Computer Exercises in Network Optimization. Springer."
  }
]